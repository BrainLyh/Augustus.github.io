<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>X86架构基础 | PlayDumb</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="x86架构基础内容">
<meta property="og:type" content="article">
<meta property="og:title" content="X86架构基础">
<meta property="og:url" content="http://example.com/2021/09/21/BO2-X86%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="PlayDumb">
<meta property="og:description" content="x86架构基础内容">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow1_files/image009.png">
<meta property="og:image" content="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow1_files/image021.png">
<meta property="og:image" content="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow1_files/image022.png">
<meta property="og:image" content="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow2_files/image001.png">
<meta property="og:image" content="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow2_files/image003.png">
<meta property="article:published_time" content="2021-09-20T16:00:00.000Z">
<meta property="article:modified_time" content="2022-08-17T03:54:17.950Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow1_files/image009.png">
  
    <link rel="alternate" href="/atom.xml" title="PlayDumb" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">PlayDumb</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-BO2-X86架构基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/21/BO2-X86%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2021-09-20T16:00:00.000Z" itemprop="datePublished">2021-09-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/pwn/">pwn</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      X86架构基础
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>x86架构基础内容</p>
<span id="more"></span>

<h1 id="BUFFER-OVERFLOW"><a href="#BUFFER-OVERFLOW" class="headerlink" title="BUFFER OVERFLOW"></a>BUFFER OVERFLOW</h1><h2 id="The-Basic-of-x86-Architecture"><a href="#The-Basic-of-x86-Architecture" class="headerlink" title="The Basic of x86 Architecture"></a>The Basic of x86 Architecture</h2><table>
<thead>
<tr>
<th align="left">寄存器名</th>
<th align="left">大小</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">AL,AH&#x2F;AX&#x2F;EAX</td>
<td align="left">8，8&#x2F;16&#x2F;32</td>
<td>用于算术计算的主寄存器。 也称为累加器，因为它保存算术运算的结果和函数返回值。</td>
</tr>
<tr>
<td align="left">BL,BH&#x2F;BX&#x2F;EBX</td>
<td align="left">8,8&#x2F;16&#x2F;32</td>
<td>基址寄存器。 指向 DS 段中数据的指针。 用于存储程序的基地址</td>
</tr>
<tr>
<td align="left">CL,DH&#x2F;CX&#x2F;ECX</td>
<td align="left">8,8&#x2F;16&#x2F;32</td>
<td>计数器寄存器通常用于保存一个值，该值表示一个过程要重复的次数。 用于循环和字符串操作。</td>
</tr>
<tr>
<td align="left">DL,DH&#x2F;DX&#x2F;EDX</td>
<td align="left">8,8&#x2F;16&#x2F;32</td>
<td>通用寄存器。 也用于 I&#x2F;O 操作。 帮助将 EAX 扩展到 64 位</td>
</tr>
<tr>
<td align="left">SI&#x2F;ESI</td>
<td align="left">16&#x2F;32</td>
<td>源索引寄存器。 指向 DS 寄存器指向的段中的数据的指针。 在字符串和数组操作中用作偏移地址。 它保存读取数据的地址。</td>
</tr>
<tr>
<td align="left">DI&#x2F;EDI</td>
<td align="left">16&#x2F;32</td>
<td>目标索引寄存器。 指向 ES 寄存器指向的段中的数据（或目标）的指针。 在字符串和数组操作中用作偏移地址。 它保存所有字符串操作的隐含写地址。</td>
</tr>
<tr>
<td align="left">BP&#x2F;EBP</td>
<td align="left">16&#x2F;32</td>
<td>基指针。 指向堆栈上数据的指针（在 SS 段中）。 它指向当前堆栈帧的底部。 它用于引用局部变量。</td>
</tr>
<tr>
<td align="left">SP&#x2F;ESP</td>
<td align="left">16&#x2F;32</td>
<td>堆栈指针（在 SS 段中）。 它指向当前堆栈帧的顶部。 它用于引用局部变量。</td>
</tr>
</tbody></table>
<p>​													表1:X86 处理器和使用</p>
<h1 id="THE-SEGMENT-REGISTERS"><a href="#THE-SEGMENT-REGISTERS" class="headerlink" title="THE SEGMENT REGISTERS"></a>THE SEGMENT REGISTERS</h1><p>六个段寄存器保存了16位的段选择器。一个段选择器是一个在内存中定义了一个段的特殊的指针。为了在内存中访问一个特别的段，这个段的段选择器必须存在于合适的段寄存器中。四个段寄存器CS,DS,ES和SS和在 intel 8086 和 intel 286 处理器中的段寄存器一样，同时 FS 和 GS 在 intel 32位架构中被引入。</p>
<p>段寄存器如何被使用取决于操作系统正在使用的内存管理模式。当使用 flat (unsegmented) 内存模式，段寄存器会随着指向部分重叠段的段选择器而被加载，每一个起始地址为 0 地址的线地址空间如图6所示。这些部分重叠的段之后会组成程序的线性地址空间。有两个特殊的部分重叠的段被定义：一个是 code 另一个是 data and stacks。CS 段寄存器指向了 code 段，剩下的所有段寄存器指向了 data and stack 段。</p>
<table>
<thead>
<tr>
<th>段寄存器</th>
<th>大小(bits)</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>CS</td>
<td>16</td>
<td>程序段寄存器。代码段的基地址(.text section).常用来获取指令</td>
</tr>
<tr>
<td>DS</td>
<td>16</td>
<td>数据寄存器。变量的默认地址(.data section).常用来数据获取。</td>
</tr>
<tr>
<td>ES</td>
<td>16</td>
<td>额外的段寄存器。在字符串操作过程中使用</td>
</tr>
<tr>
<td>SS</td>
<td>16</td>
<td>栈段的寄存器。栈段的基地址。当隐式的使用SP或ESP或显式</td>
</tr>
<tr>
<td>FS</td>
<td>16</td>
<td>额外的段寄存器</td>
</tr>
<tr>
<td>GS</td>
<td>16</td>
<td>额外的段寄存器</td>
</tr>
<tr>
<td></td>
<td></td>
<td>表2:X86段寄存器和它们的用处</td>
</tr>
</tbody></table>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow1_files/image009.png" alt="The use of segment registers for flat memory model"></p>
<p>​											图6:FLAT内存模式的段寄存器示例</p>
<h1 id="INSTRUCTION-POINTER-REGISTER-EIP"><a href="#INSTRUCTION-POINTER-REGISTER-EIP" class="headerlink" title="INSTRUCTION POINTER REGISTER - EIP"></a>INSTRUCTION POINTER REGISTER - EIP</h1><p>EIP 寄存器包含了当前代码段和下一条将要被执行的指令之间的偏移。默认在执行一系列指令例如 JMP,JCC,CALL,RET and IRET 等在代码线性的或者前移或者后移的代码中从一条指令边界到相邻的指令。</p>
<p>EIP 不能直接的被软件访问。它被控制传输指令例如 JMP,JCC,CALL,RET 和 IRET隐形的控制。唯一的读取 EIP 寄存器值的方法是执行 CALL 指令之后读取指令指针从函数栈的返回值。原因是因为当 CALL 指令被执行，调用后的相邻的地址会立刻跟在 CALL 之后，作为函数返回地址被保存在站上。之后，EIP 可以通过修改在栈上的返回指令指针的值被间接的加载，并且执行返回 RET&#x2F;IRET 指令。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>大小(bits)</th>
<th>用处</th>
</tr>
</thead>
<tbody><tr>
<td>IP&#x2F;EIP</td>
<td>16&#x2F;32</td>
<td>指令指针保存了下一条将要被执行的指令的地址</td>
</tr>
</tbody></table>
<h1 id="THE-ASSEMBLY-LANGUAGE"><a href="#THE-ASSEMBLY-LANGUAGE" class="headerlink" title="THE ASSEMBLY LANGUAGE"></a>THE ASSEMBLY LANGUAGE</h1><p>为了理解缓冲区溢出的操作，一些汇编的知识非常必要。</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>机器语言</td>
<td>是计算机真正看到的处理的。计算机看到的每一条命令是一个活着一串给定的数字。是二进制数据或者为了易读转换为16进制</td>
<td>83 ec 08 -&gt; sub $0x8,%esp</td>
</tr>
<tr>
<td>汇编语言</td>
<td>和机器语言一样，除了命令编号已被更易读且更易于记忆的字母序列所取代</td>
<td>push ebp</td>
</tr>
</tbody></table>
<p>​																表1:语言分类</p>
<p>汇编直接处理处理器和内存位置的寄存器.下面列出了一些通常适用于大多数汇编语言的一般规则:</p>
<ul>
<li>资源可以是内存，寄存器和常量</li>
<li>目标可以是内存或者非分段寄存器</li>
<li>只有源和目标之一可以是内存</li>
<li>源和目标必须是同样大小</li>
</ul>
<p>操作码是程序运行时的真正指令。每一个操作码对应一行代码，其中包含了操作码和操作码所需的操作数。操作数的数量变化取决于操作码。整个可用的操作码集合对一个处理器来说被称为一个指令集。根据处理器和使用的反汇编器不同，操作码可能会有相反的顺序。例如在 windows 上：</p>
<p><code>MOV dst, src</code></p>
<p>作用和 linux 上如下代码一致</p>
<p><code>MOV %src, %dst</code></p>
<p>Windows 使用的是 intel 汇编格式而 linux 使用的是 AT&amp;T，MAC OS 使用的是 Motorola 处理器指令集。High Level Assembly(HLA) 同样在一些程序中非常受欢迎。</p>
<table>
<thead>
<tr>
<th><strong>Instruction Category</strong></th>
<th><strong>Meaning</strong></th>
<th><strong>Example</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Data Transfer</td>
<td>move from source to destination</td>
<td>mov, lea, les, push, pop, pushf, popf</td>
</tr>
<tr>
<td>Arithmetic(计算)</td>
<td>arithmetic on integers</td>
<td>add, adc, sub, sbb, mul, imul, div, idiv, cmp, neg, inc, dec, xadd,cmpxchg</td>
</tr>
<tr>
<td>Floating point</td>
<td>arithmetic on floating point</td>
<td>fadd, fsub, fmul, div, cmp</td>
</tr>
<tr>
<td>Logical, Shift, Rotate and Bit(逻辑，移位，旋转和为)</td>
<td>bitwise logic operations</td>
<td>and, or, xor, not, shl&#x2F;sal, shr, sar, shld and shrd, ror, rol, rcr and rcl</td>
</tr>
<tr>
<td>Control transfer</td>
<td>conditional and unconditional jumps, procedure calls</td>
<td>jmp, jcc, call, ret, int, into, bound.</td>
</tr>
<tr>
<td>String</td>
<td>move, compare, input and output</td>
<td>movs, lods, stos, scas, cmps, outs, rep, repz, repe, repnz, repne, ins</td>
</tr>
<tr>
<td>I&#x2F;O</td>
<td>For input and output</td>
<td>in, out</td>
</tr>
<tr>
<td>Conversion</td>
<td>Provide assembly data types conversion</td>
<td>movzx, movsx, cbw, cwd, cwde, cdq, bswap, xlat</td>
</tr>
<tr>
<td>Miscellaneous(其他的)</td>
<td>manipulate individual flags, provide special processor services, or handle privileged mode operations(或者处理特权模式操作)</td>
<td>clc, stc, cmc, cld, std, cl, sti</td>
</tr>
</tbody></table>
<p>​														表2:汇编指令集集合</p>
<h1 id="进程加载"><a href="#进程加载" class="headerlink" title="进程加载"></a>进程加载</h1><p>​		在 Linux 中，从文件系统（使用execve() 或spawn() 系统调用）加载的进程采用ELF 格式。如果文件系统位于面向块的设备上，则代码和数据将加载到主内存中。如果文件系统是内存映射的（例如 ROM&#x2F;Flash 映像），则无需将代码加载到 RAM 中，而是可以就地执行。这种方法使所有 RAM 都可用于数据和堆栈，而将代码留在 ROM 或闪存中。在所有情况下，如果同一个进程被多次加载，其代码将被共享。在我们运行可执行文件之前，首先我们必须将它加载到内存中。这是由<strong>loader</strong>完成的，它通常是操作系统的一部分。加载器做以下事情：</p>
<ul>
<li><p>内存和访问验证：</p>
<p>首先，OS 系统内核读入程序文件的头信息，并对类型、访问权限和权限、内存要求及其运行指令的能力进行验证。它确认文件是一个可执行映像并计算内存需求。</p>
</li>
<li><p>流程设置，包括：</p>
<ol>
<li>为程序的执行分配主存</li>
<li>将地址空间从辅存复制到主存。</li>
<li>将.text 和.data 部分从可执行文件复制到主存中。</li>
<li>将程序参数（例如，命令行参数）复制到堆栈中。</li>
<li>初始化寄存器：将 esp设置为指向栈顶，清除其余部分。</li>
<li>跳转到启动例程，它：从堆栈中复制 <code>main()</code>的参数，并跳转到<code>main()</code></li>
</ol>
</li>
</ul>
<p>​        地址空间是包含程序代码、堆栈和数据段的内存空间，换言之，是程序运行时使用的所有数据。内存布局通常由三段（文本、数据和堆栈）组成，简化形式如图 4 所示。动态数据段也称为<strong>堆</strong>，是动态分配内存的地方（例如来自malloc( ) 和new) 。动态分配的内存是在<strong>运行时而</strong> 不是<strong>编译</strong>&#x2F;<strong>链接时</strong>分配的内存 . 这种组织允许在堆（显式）和栈（隐式）之间对动态分配的内存进行任何划分。这就解释了为什么栈向下增长而堆向上增长。</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow1_files/image021.png" alt="C 进程的内存布局"></p>
<p>​													图4:进程的内存布局</p>
<h1 id="运行时数据结构"><a href="#运行时数据结构" class="headerlink" title="运行时数据结构"></a>运行时数据结构</h1><p>进程是一个正在运行的程序。这意味着操作系统已将程序的可执行文件加载到内存中，已安排它访问其命令行参数和环境变量，并已启动它运行。从概念上讲，一个进程有五个不同的内存区域分配给它，如表 1 中所列（参见图 4）</p>
<table>
<thead>
<tr>
<th><strong>区域</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Code&#x2F;text segment</td>
<td>通常称为文本段，这是可执行指令所在的区域。例如，Linux&#x2F;Unix 会安排一些事情，以便同一程序的多个运行实例在可能的情况下共享它们的代码。<strong>任何时候都只有一个相同程序的指令副本驻留在内存中</strong>。包含文本段的可执行文件部分是文本段。</td>
</tr>
<tr>
<td>Initialized data – data segment</td>
<td>使用非零值初始化的静态分配和全局数据位于数据段中。<strong>运行相同程序的每个进程都有自己的数据段</strong>。包含数据段的可执行文件部分是数据段。</td>
</tr>
<tr>
<td>Uninitialized data – bss segment</td>
<td>BSS 代表“<strong>由符号开始</strong>的<strong>块</strong>”。 默认情况下初始化为零的全局和静态分配的数据保存在进程的所谓 BSS 区域中。<strong>每个运行相同程序的进程都有自己的 BSS 区域</strong>。运行时将BSS数据放在数据段中。在可执行文件中，它们存储在 BSS 部分。对于 Linux&#x2F;Unix 可执行文件的格式，只有初始化为非零值的变量才会占用可执行文件磁盘文件中的空间。</td>
</tr>
<tr>
<td>Heap</td>
<td>堆是动态内存（由malloc() 、 calloc() 、realloc() 和new – C++ 获得）的来源。堆上的所有内容都是<strong>匿名的</strong>，因此您只能通过指针访问其中的一部分。随着在堆上分配内存，进程的地址空间会增长。尽管可以将内存返还给系统并缩小进程的地址空间，但这几乎从未做过，因为它将再次分配给其他进程。  释放的内存（ free()和 delete ）回到堆，创建所谓的<strong>holes</strong>。  <strong>堆是典型的向上生长</strong>。这意味着添加到堆中的连续项被添加到数字大于前项的地址处。堆 在数据段的BSS区域 之后立即开始也是典型的 。 堆的末尾由一个称为<strong>break</strong>的指针标记。您不能参考休息时间。但是，您可以将中断指针（通过 brk() 和 sbrk() 系统调用）移动到新位置以增加可用的堆内存量。</td>
</tr>
<tr>
<td>Stack</td>
<td>堆栈段是分配局部（自动）变量的地方 。在 C 程序中，局部变量是在函数体的左大括号内声明的所有变量，包括 main() 或其他未定义为静态的左大括号。数据在后进<strong>先出后</strong>出或压入堆栈 (LIFO) 规则。堆栈保存局部变量、临时信息&#x2F;数据、函数参数、返回地址等。当一个函数被调用时，一个栈帧（或一个过程激活记录）被创建并被推送到栈顶。该堆栈帧包含诸如调用函数的地址以及函数完成时跳转回的位置（返回地址）、参数、局部变量以及被调用函数所需的任何其他信息等信息。信息的顺序可能因系统和编译器而异。当一个函数返回时，堆栈帧从堆栈POPped。通常堆栈向下增长，这意味着调用链中更深的项目位于数字较低的地址并朝向堆。</td>
</tr>
</tbody></table>
<p>​																表1:可执行映像的区域</p>
<p>​		当程序运行时，初始化的数据、BSS 和堆区通常放置在称为数据段的单个连续区域中。如图 4 所示，堆栈段和代码&#x2F;文本段与数据段分开并且彼此分开。</p>
<p>​		尽管理论上堆栈和堆可以相互增长，但操作系统会阻止这种情况发生。不同sections&#x2F;segments之间的关系总结在表2中，可执行程序段和它们的位置。</p>
<table>
<thead>
<tr>
<th><strong>Executable file section</strong>(disk file)</th>
<th><strong>Address space segment</strong></th>
<th><strong>Program memory segment</strong></th>
</tr>
</thead>
<tbody><tr>
<td>.text</td>
<td>Text</td>
<td>Code</td>
</tr>
<tr>
<td>.data</td>
<td>Data</td>
<td>Initialized data</td>
</tr>
<tr>
<td>.bss</td>
<td>Data</td>
<td>BSS</td>
</tr>
<tr>
<td>-</td>
<td>Data</td>
<td>Heap</td>
</tr>
<tr>
<td>-</td>
<td>Stack</td>
<td>Stack</td>
</tr>
</tbody></table>
<p>​												Table 2: Sections vs segments.</p>
<h1 id="过程-PROCESS"><a href="#过程-PROCESS" class="headerlink" title="过程 PROCESS"></a>过程 PROCESS</h1><p>​		下图显示了典型 C 进程的内存布局。进程在进程的基地址加载段（对应于图中的“文本”和“数据”）。主堆栈位于正下方并向下生长。创建的任何其他线程都有自己的堆栈，位于主堆栈下方。每个堆栈帧都由一个保护页分隔，以检测堆栈帧之间的堆栈溢出。堆位于进程上方并向上生长。</p>
<p>​		在进程地址空间的中间，有一个区域是为共享对象保留的。创建新进程时，进程管理器首先将可执行文件中的两个段映射到内存中。然后它解码程序的 ELF 头。如果程序头指示可执行文件链接到共享库，进程管理器将从程序头中提取动态解释器的名称。动态解释器指向一个包含运行时链接器代码的共享库。进程管理器将在内存中加载这个共享库，然后将控制传递给这个库中的运行时链接器代码。</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow1_files/image022.png" alt="C 在 x86 上的进程内存布局示意图"></p>
<p>​										图5:X86上 C 的进程内存布局示意图</p>
<h1 id="THE-C-FUNCTIONS"><a href="#THE-C-FUNCTIONS" class="headerlink" title="THE C FUNCTIONS"></a><strong>THE C FUNCTIONS</strong></h1><p>​		希望我们已经有一个大致的了解对于程序是如何编译、链接和组装，然后作为程序运行的进程映像加载到内存中。在我们进一步研究堆栈之前，如果我们能够了解函数是非常有用的，因为在调用函数时会构造堆栈。 在高级语言历史中，为构建程序（结构化或过程化编程）而引入的最重要的技术之一是过程或函数。程序员使用函数将他们的程序分解成具有特定任务的较小程序段，这些程序段可以独立开发、测试和重用。其他可以互换使用的术语是例程（如汇编中所称）、过程和方法（如面向对象编程中所称）。</p>
<p>​		当函数调用发生时，它会像汇编语言中的跳转 ( JMP ) 一样改变控制流，但与跳转不同的是，当完成其任务时，函数将控制权返回给紧跟在调用 ( CALL )之后的语句或指令指令，即调用函数（caller）。当我们从内存的角度来看时，这个函数的高级抽象是在<strong>堆栈</strong>的帮助下实现的。堆栈是分配给函数运行的一部分内存。当堆栈的内容包含函数运行所需的所有数据设置好时，通常使用术语<strong>堆栈帧</strong>。堆栈帧由函数内使用的所有堆栈变量组成，包括参数、局部变量、返回地址和完成函数任务所需的其他数据。当一个函数返回到调用程序时，堆栈将被拆除（由调用者或被调用者），新的函数调用将创建一个新的堆栈。通常，函数的组件如下表所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">global_variables;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  function_name(argument <span class="built_in">list</span>);</span><br><span class="line">  function_return_address here</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return_type <span class="title function_">function_name</span><span class="params">(parameter <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  local_variables;</span><br><span class="line">  <span class="type">static</span> variables;</span><br><span class="line">  function’s code here</span><br><span class="line">  <span class="keyword">return</span> something_or_nothing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		请记住，main()也是一个函数，但具有执行点。下表列出了对上述功能组件的一些描述。</p>
<table>
<thead>
<tr>
<th><strong>成分</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>function name</td>
<td>函数名是一个符号，它实际上代表了函数代码开始的地址。在汇编语言中，符号是通过在函数代码之前键入函数名称作为标签来定义的。</td>
</tr>
<tr>
<td>function paramenters</td>
<td>函数的参数是显式提供给函数进行处理的数据项。有些函数有很多参数，有些没有，有些函数有可变数量的参数。</td>
</tr>
<tr>
<td>Local varuables</td>
<td>局部变量是函数在处理时使用的数据存储，在它返回时被丢弃。程序中的任何其他函数都无法访问函数的局部变量。</td>
</tr>
<tr>
<td>static variables</td>
<td>静态变量是函数在处理时使用的数据存储，之后不会被丢弃，而是在每次激活函数代码时重复使用。程序的任何其他部分都无法访问此数据。</td>
</tr>
<tr>
<td>Global variables</td>
<td>全局变量是函数用于处理的数据存储，在函数外部进行管理。程序中的任何其他函数都可以访问函数的全局变量。</td>
</tr>
<tr>
<td>return address</td>
<td>返回地址是函数必须返回的内存地址，以便继续执行下一个程序。</td>
</tr>
<tr>
<td>Return value</td>
<td>返回值是将数据传输回主程序（或调用程序）的主要方法。大多数编程语言只允许一个函数有一个返回值。</td>
</tr>
</tbody></table>
<p>​														表1:函数使用中的术语</p>
<p>​		在一个进程地址空间和物理地址映射中的函数调用过程中的堆栈使用情况可以通过下图进行说明：</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow2_files/image001.png" alt="Stack in process address space and  physical address mapping"></p>
<p>​												图1:进程地址空间中的堆栈</p>
<h1 id="处理器的堆栈内存"><a href="#处理器的堆栈内存" class="headerlink" title="处理器的堆栈内存"></a>处理器的堆栈内存</h1><p>​		希望前面的部分已经为您提供了大致的了解。现在我们将把讨论范围缩小到一个堆栈。要完全了解缓冲区溢出的环境是如何发生的，必须完全了解堆栈的布局和操作。如前所述，堆栈段包含一个堆栈、一个入口&#x2F;出口、LIFO 结构。在 x86 架构上，堆栈向下增长，这意味着较新的数据将分配在地址少于之前推送到堆栈上的元素的地址处。当EBP指向的边界位于栈底，ESP指向的边界位于栈顶时，该栈通常称为栈帧（或java中的过程激活记录）。每个函数调用都会创建一个新的堆栈帧并“向下堆叠”到前一个堆栈上，每个函数都会跟踪调用链或序列，即调用它的例程以及完成后返回的位置（图 3）。使用一个非常简单的 C 程序框架，下面试图找出函数调用和堆栈帧的构造&#x2F;销毁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">c</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">b</span>();</span><br><span class="line">  <span class="built_in">c</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">b</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">c</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">a</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		通过只分析栈区域，下面的过程展示了上面的程序在运行的时发生了什么。在程序的终点应该是栈平衡的。</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow2_files/image003.png" alt="Stack: Stack frame and function call, construction and destruction"></p>
<p>​													图3:栈帧和程序调用</p>
<p>​		通过参考前面的程序示例和图 3，当程序开始在函数<code>main() 中</code>执行时，将创建堆栈帧，并在堆栈上为<code>main() 中</code>声明的所有变量分配空间。然后，当<code>main()</code>调用函数 <code>a() 时</code>，会为<code>main()</code>堆栈顶部的 <code>a()</code>中的变量创建新的堆栈帧。<code>main()</code>传递给 <code>a() 的</code>任何参数都存储在堆栈中。如果 <code>a()</code>要调用任何其他函数，例如<code>b()</code>和<code>c()</code>，新的堆栈帧将分配在新的堆栈顶部。请注意，执行的顺序是按顺序发生的。当 <code>c(),b()</code>和<code>a()</code>返回，它们的局部变量的存储被取消分配，堆栈帧被销毁，堆栈顶部返回到先前的状态。执行顺序正好相反。可以看出，栈区分配的内存在程序执行过程中被使用和重用。应该清楚的是，在该区域分配的内存将包含以前使用留下的垃圾值。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/21/BO2-X86%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/" data-id="cl6x1oiit00006mgq6xv3g3v2" data-title="X86架构基础" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/10/09/BO7-%E6%A0%88%E6%93%8D%E4%BD%9C/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          栈操作
        
      </div>
    </a>
  
  
    <a href="/2021/09/21/BO6-%E5%87%BD%E6%95%B0%E6%A0%88/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">函数栈</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/pwn/">pwn</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/WP/" rel="tag">WP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/adword/" rel="tag">adword</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf/" rel="tag">ctf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/" rel="tag">格式化字符串漏洞</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/WP/" style="font-size: 10px;">WP</a> <a href="/tags/adword/" style="font-size: 10px;">adword</a> <a href="/tags/ctf/" style="font-size: 10px;">ctf</a> <a href="/tags/pwn/" style="font-size: 20px;">pwn</a> <a href="/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/" style="font-size: 10px;">格式化字符串漏洞</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/28/adworld-pwn/">攻防世界-新手区</a>
          </li>
        
          <li>
            <a href="/2022/06/22/Format%20String%20Vulnerailites/">格式化字符串漏洞</a>
          </li>
        
          <li>
            <a href="/2021/10/11/BO9-shellcode/">shell code</a>
          </li>
        
          <li>
            <a href="/2021/10/09/BO8-%E6%A0%88%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/">栈缓冲区溢出</a>
          </li>
        
          <li>
            <a href="/2021/10/09/BO7-%E6%A0%88%E6%93%8D%E4%BD%9C/">栈操作</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>